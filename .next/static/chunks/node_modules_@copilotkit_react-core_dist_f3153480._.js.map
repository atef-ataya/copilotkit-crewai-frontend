{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/lib/status-checker.ts"],"sourcesContent":["import {\n  COPILOT_CLOUD_API_URL,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  Severity,\n} from \"@copilotkit/shared\";\n\nconst STATUS_CHECK_INTERVAL = 1000 * 60 * 5; // 5 minutes\n\nexport type Status = {\n  severity: Severity;\n  message: string;\n};\n\nexport class StatusChecker {\n  private activeKey: string | null = null;\n  private intervalId: ReturnType<typeof setInterval> | null = null;\n  private instanceCount = 0;\n  private lastResponse: Status | null = null;\n\n  async start(publicApiKey: string, onUpdate?: (status: Status | null) => void) {\n    this.instanceCount++;\n    if (this.activeKey === publicApiKey) return;\n\n    if (this.intervalId) clearInterval(this.intervalId);\n\n    const checkStatus = async () => {\n      try {\n        const response = await fetch(`${COPILOT_CLOUD_API_URL}/ciu`, {\n          method: \"GET\",\n          headers: {\n            [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey,\n          },\n        }).then((response) => response.json() as Promise<Status>);\n        this.lastResponse = response;\n        onUpdate?.(response);\n        return response;\n      } catch (error) {\n        // Silently fail\n        return null;\n      }\n    };\n\n    const initialResponse = await checkStatus();\n    this.intervalId = setInterval(checkStatus, STATUS_CHECK_INTERVAL);\n    this.activeKey = publicApiKey;\n    return initialResponse;\n  }\n\n  getLastResponse() {\n    return this.lastResponse;\n  }\n\n  stop() {\n    this.instanceCount--;\n    if (this.instanceCount === 0) {\n      if (this.intervalId) {\n        clearInterval(this.intervalId);\n        this.intervalId = null;\n        this.activeKey = null;\n        this.lastResponse = null;\n      }\n    }\n  }\n}\n"],"names":["response"],"mappings":";;;;;AAAA;;;AAMA,IAAM,wBAAwB,MAAO,KAAK;AAOnC,IAAM,gBAAN,MAAoB;IAApB,aAAA;QACL,IAAA,CAAQ,SAAA,GAA2B;QACnC,IAAA,CAAQ,UAAA,GAAoD;QAC5D,IAAA,CAAQ,aAAA,GAAgB;QACxB,IAAA,CAAQ,YAAA,GAA8B;IAAA;IAEhC,MAAM,YAAA,EAAsB,QAAA,EAA4C;QAAA,OAAA,CAAA,GAAA,8KAAA,CAAA,UAAA,EAAA,IAAA,EAAA,MAAA;YAC5E,IAAA,CAAK,aAAA;YACL,IAAI,IAAA,CAAK,SAAA,KAAc,cAAc;YAErC,IAAI,IAAA,CAAK,UAAA,EAAY,cAAc,IAAA,CAAK,UAAU;YAElD,MAAM,cAAc,uLAAY,UAAA,EAAA,IAAA,EAAA,MAAA;oBAC9B,IAAI;wBACF,MAAM,WAAW,MAAM,MAAM,2KAAG,wBAAA,CAAA,IAAA,CAAA,EAA6B;4BAC3D,QAAQ;4BACR,SAAS;gCACP,yKAAC,sCAAmC,CAAA,EAAG;4BACzC;wBACF,CAAC,EAAE,IAAA,CAAK,CAACA,YAAaA,UAAS,IAAA,CAAK,CAAoB;wBACxD,IAAA,CAAK,YAAA,GAAe;wBACpB,YAAA,OAAA,KAAA,IAAA,SAAW;wBACX,OAAO;oBACT,EAAA,OAAS,OAAP;wBAEA,OAAO;oBACT;gBACF;YAEA,MAAM,kBAAkB,MAAM,YAAY;YAC1C,IAAA,CAAK,UAAA,GAAa,YAAY,aAAa,qBAAqB;YAChE,IAAA,CAAK,SAAA,GAAY;YACjB,OAAO;QACT;IAAA;IAEA,kBAAkB;QAChB,OAAO,IAAA,CAAK,YAAA;IACd;IAEA,OAAO;QACL,IAAA,CAAK,aAAA;QACL,IAAI,IAAA,CAAK,aAAA,KAAkB,GAAG;YAC5B,IAAI,IAAA,CAAK,UAAA,EAAY;gBACnB,cAAc,IAAA,CAAK,UAAU;gBAC7B,IAAA,CAAK,UAAA,GAAa;gBAClB,IAAA,CAAK,SAAA,GAAY;gBACjB,IAAA,CAAK,YAAA,GAAe;YACtB;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/usage-banner.tsx"],"sourcesContent":["import { Severity, CopilotKitError, ERROR_NAMES } from \"@copilotkit/shared\";\n\ninterface UsageBannerProps {\n  severity?: Severity;\n  message?: string;\n  icon?: React.ReactNode;\n  actions?: {\n    primary?: {\n      label: string;\n      onClick: () => void;\n    };\n    secondary?: {\n      label: string;\n      onClick: () => void;\n    };\n  };\n}\n\nconst defaultIcons: Record<Severity, JSX.Element> = {\n  [Severity.Error]: (\n    <svg\n      viewBox=\"0 0 24 24\"\n      width=\"20\"\n      height=\"20\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\" />\n      <line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\" />\n    </svg>\n  ),\n};\n\nexport function UsageBanner({\n  severity = Severity.Error,\n  message = \"\",\n  icon,\n  actions,\n}: UsageBannerProps) {\n  if (!message || !severity) {\n    return null;\n  }\n\n  const Icon = icon || defaultIcons[severity];\n\n  const bgColor = {\n    info: \"#dbeafe\",\n    warning: \"#fef3c7\",\n    error: \"#fee2e2\",\n  }[severity];\n\n  const textColor = {\n    info: \"#1e40af\",\n    warning: \"#854d0e\",\n    error: \"#991b1b\",\n  }[severity];\n\n  const iconColor = {\n    info: \"#3b82f6\",\n    warning: \"#eab308\",\n    error: \"#ef4444\",\n  }[severity];\n\n  const primaryButtonColor = {\n    info: \"#3b82f6\",\n    warning: \"#eab308\",\n    error: \"#ef4444\",\n  }[severity];\n\n  const primaryButtonHoverColor = {\n    info: \"#2563eb\",\n    warning: \"#ca8a04\",\n    error: \"#dc2626\",\n  }[severity];\n\n  return (\n    <div\n      style={{\n        position: \"fixed\",\n        bottom: \"16px\",\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        maxWidth: \"90%\",\n        zIndex: 9999,\n      }}\n    >\n      <div\n        style={{\n          display: \"flex\",\n          flexWrap: \"wrap\",\n          alignItems: \"center\",\n          gap: \"12px\",\n          borderRadius: \"9999px\",\n          border: \"1px solid #e5e7eb\",\n          backgroundColor: bgColor,\n          padding: \"8px 16px\",\n          boxShadow: \"0 4px 6px -1px rgba(0, 0, 0, 0.1)\",\n        }}\n      >\n        <div style={{ color: iconColor }}>{Icon}</div>\n        <span\n          style={{\n            flex: 1,\n            fontSize: \"14px\",\n            fontWeight: 500,\n            color: textColor,\n            whiteSpace: \"normal\",\n            wordBreak: \"break-word\",\n          }}\n        >\n          {message}\n        </span>\n        <div\n          style={{\n            display: \"flex\",\n            gap: \"8px\",\n            flexWrap: \"wrap\",\n          }}\n        >\n          {actions?.secondary && (\n            <button\n              onClick={actions.secondary.onClick}\n              style={{\n                borderRadius: \"9999px\",\n                padding: \"4px 12px\",\n                fontSize: \"14px\",\n                fontWeight: 500,\n                color: textColor,\n                backgroundColor: \"transparent\",\n                border: \"none\",\n                cursor: \"pointer\",\n                transition: \"background-color 0.2s\",\n              }}\n              onMouseOver={(e) => (e.currentTarget.style.backgroundColor = \"rgba(255,255,255,0.5)\")}\n              onMouseOut={(e) => (e.currentTarget.style.backgroundColor = \"transparent\")}\n            >\n              {actions.secondary.label}\n            </button>\n          )}\n          {actions?.primary && (\n            <button\n              onClick={actions.primary.onClick}\n              style={{\n                borderRadius: \"9999px\",\n                padding: \"4px 12px\",\n                fontSize: \"14px\",\n                fontWeight: 500,\n                color: \"#fff\",\n                backgroundColor: primaryButtonColor,\n                border: \"none\",\n                cursor: \"pointer\",\n                transition: \"background-color 0.2s\",\n              }}\n              onMouseOver={(e) => (e.currentTarget.style.backgroundColor = primaryButtonHoverColor)}\n              onMouseOut={(e) => (e.currentTarget.style.backgroundColor = primaryButtonColor)}\n            >\n              {actions.primary.label}\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport function renderCopilotKitUsage(error: CopilotKitError) {\n  switch (error.name) {\n    case ERROR_NAMES.CONFIGURATION_ERROR:\n      return <UsageBanner severity={error.severity} message={error.message} />;\n    case ERROR_NAMES.MISSING_PUBLIC_API_KEY_ERROR:\n      return (\n        <UsageBanner\n          severity={error.severity}\n          message={error.message}\n          actions={{\n            primary: {\n              label: \"Sign In\",\n              onClick: () => {\n                window.location.href = \"https://cloud.copilotkit.ai\";\n              },\n            },\n          }}\n        />\n      );\n    case ERROR_NAMES.UPGRADE_REQUIRED_ERROR:\n      return (\n        <UsageBanner\n          severity={error.severity}\n          message={error.message}\n          actions={{\n            primary: {\n              label: \"Upgrade\",\n              onClick: () => {\n                window.location.href = \"https://copilotkit.ai/\";\n              },\n            },\n          }}\n        />\n      );\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,UAA2B,mBAAmB;AAoBnD,SAUE,KAVF;;;AAFJ,IAAM,eAA8C;IAClD,yKAAC,WAAA,CAAS,KAAK,CAAA,EACb,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;QACC,SAAQ;QACR,OAAM;QACN,QAAO;QACP,QAAO;QACP,aAAY;QACZ,MAAK;QACL,eAAc;QACd,gBAAe;QAEf,UAAA;YAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,UAAA;gBAAO,IAAG;gBAAK,IAAG;gBAAK,GAAE;YAAA,CAAK;YAC/B,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;gBAAI,IAAG;YAAA,CAAK;YACpC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,IAAG;gBAAI,IAAG;gBAAI,IAAG;gBAAK,IAAG;YAAA,CAAK;SAAA;IAAA;AAG1C;AAEO,SAAS,YAAY,EAC1B,mLAAW,WAAA,CAAS,KAAA,EACpB,UAAU,EAAA,EACV,IAAA,EACA,OAAA,EACF,EAAqB;IACnB,IAAI,CAAC,WAAW,CAAC,UAAU;QACzB,OAAO;IACT;IAEA,MAAM,OAAO,QAAQ,YAAA,CAAa,QAAQ,CAAA;IAE1C,MAAM,UAAU;QACd,MAAM;QACN,SAAS;QACT,OAAO;IACT,CAAA,CAAE,QAAQ,CAAA;IAEV,MAAM,YAAY;QAChB,MAAM;QACN,SAAS;QACT,OAAO;IACT,CAAA,CAAE,QAAQ,CAAA;IAEV,MAAM,YAAY;QAChB,MAAM;QACN,SAAS;QACT,OAAO;IACT,CAAA,CAAE,QAAQ,CAAA;IAEV,MAAM,qBAAqB;QACzB,MAAM;QACN,SAAS;QACT,OAAO;IACT,CAAA,CAAE,QAAQ,CAAA;IAEV,MAAM,0BAA0B;QAC9B,MAAM;QACN,SAAS;QACT,OAAO;IACT,CAAA,CAAE,QAAQ,CAAA;IAEV,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;QACC,OAAO;YACL,UAAU;YACV,QAAQ;YACR,MAAM;YACN,WAAW;YACX,UAAU;YACV,QAAQ;QACV;QAEA,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;YACC,OAAO;gBACL,SAAS;gBACT,UAAU;gBACV,YAAY;gBACZ,KAAK;gBACL,cAAc;gBACd,QAAQ;gBACR,iBAAiB;gBACjB,SAAS;gBACT,WAAW;YACb;YAEA,UAAA;gBAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;oBAAI,OAAO;wBAAE,OAAO;oBAAU;oBAAI,UAAA;gBAAA,CAAK;gBACxC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;oBACC,OAAO;wBACL,MAAM;wBACN,UAAU;wBACV,YAAY;wBACZ,OAAO;wBACP,YAAY;wBACZ,WAAW;oBACb;oBAEC,UAAA;gBAAA;gBAEH,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;oBACC,OAAO;wBACL,SAAS;wBACT,KAAK;wBACL,UAAU;oBACZ;oBAEC,UAAA;wBAAA,CAAA,WAAA,OAAA,KAAA,IAAA,QAAS,SAAA,KACR,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,UAAA;4BACC,SAAS,QAAQ,SAAA,CAAU,OAAA;4BAC3B,OAAO;gCACL,cAAc;gCACd,SAAS;gCACT,UAAU;gCACV,YAAY;gCACZ,OAAO;gCACP,iBAAiB;gCACjB,QAAQ;gCACR,QAAQ;gCACR,YAAY;4BACd;4BACA,aAAa,CAAC,IAAO,EAAE,aAAA,CAAc,KAAA,CAAM,eAAA,GAAkB;4BAC7D,YAAY,CAAC,IAAO,EAAE,aAAA,CAAc,KAAA,CAAM,eAAA,GAAkB;4BAE3D,UAAA,QAAQ,SAAA,CAAU,KAAA;wBAAA;wBACrB,CAED,WAAA,OAAA,KAAA,IAAA,QAAS,OAAA,KACR,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,UAAA;4BACC,SAAS,QAAQ,OAAA,CAAQ,OAAA;4BACzB,OAAO;gCACL,cAAc;gCACd,SAAS;gCACT,UAAU;gCACV,YAAY;gCACZ,OAAO;gCACP,iBAAiB;gCACjB,QAAQ;gCACR,QAAQ;gCACR,YAAY;4BACd;4BACA,aAAa,CAAC,IAAO,EAAE,aAAA,CAAc,KAAA,CAAM,eAAA,GAAkB;4BAC7D,YAAY,CAAC,IAAO,EAAE,aAAA,CAAc,KAAA,CAAM,eAAA,GAAkB;4BAE3D,UAAA,QAAQ,OAAA,CAAQ,KAAA;wBAAA;qBACnB;gBAAA;aAEJ;QAAA;IACF;AAGN;AAEO,SAAS,sBAAsB,KAAA,EAAwB;IAC5D,OAAQ,MAAM,IAAA,EAAM;QAClB,KAAK,sLAAA,CAAY,mBAAA;YACf,OAAO,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,aAAA;gBAAY,UAAU,MAAM,QAAA;gBAAU,SAAS,MAAM,OAAA;YAAA,CAAS;QACxE,6KAAK,cAAA,CAAY,4BAAA;YACf,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,aAAA;gBACC,UAAU,MAAM,QAAA;gBAChB,SAAS,MAAM,OAAA;gBACf,SAAS;oBACP,SAAS;wBACP,OAAO;wBACP,SAAS,MAAM;4BACb,OAAO,QAAA,CAAS,IAAA,GAAO;wBACzB;oBACF;gBACF;YAAA;QAGN,6KAAK,cAAA,CAAY,sBAAA;YACf,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,aAAA;gBACC,UAAU,MAAM,QAAA;gBAChB,SAAS,MAAM,OAAA;gBACf,SAAS;oBACP,SAAS;wBACP,OAAO;wBACP,SAAS,MAAM;4BACb,OAAO,QAAA,CAAS,IAAA,GAAO;wBACzB;oBACF;gBACF;YAAA;IAGR;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/toast/exclamation-mark-icon.tsx"],"sourcesContent":["import React from \"react\";\n\nexport const ExclamationMarkIcon = ({\n  className,\n  style,\n}: {\n  className?: string;\n  style?: React.CSSProperties;\n}) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"24\"\n    height=\"24\"\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    stroke=\"currentColor\"\n    strokeWidth=\"2\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    className={`lucide lucide-circle-alert ${className ? className : \"\"}`}\n    style={style}\n  >\n    <circle cx=\"12\" cy=\"12\" r=\"10\" />\n    <line x1=\"12\" x2=\"12\" y1=\"8\" y2=\"12\" />\n    <line x1=\"12\" x2=\"12.01\" y1=\"16\" y2=\"16\" />\n  </svg>\n);\n"],"names":[],"mappings":";;;;AASE,SAaE,KAbF;;AAPK,IAAM,sBAAsB,CAAC,EAClC,SAAA,EACA,KAAA,EACF,GAIE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;QACC,OAAM;QACN,OAAM;QACN,QAAO;QACP,SAAQ;QACR,MAAK;QACL,QAAO;QACP,aAAY;QACZ,eAAc;QACd,gBAAe;QACf,WAAW,CAAA,2BAAA,EAA8B,YAAY,YAAY,IAAA;QACjE;QAEA,UAAA;YAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,UAAA;gBAAO,IAAG;gBAAK,IAAG;gBAAK,GAAE;YAAA,CAAK;YAC/B,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,IAAG;gBAAK,IAAG;gBAAK,IAAG;gBAAI,IAAG;YAAA,CAAK;YACrC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,IAAG;gBAAK,IAAG;gBAAQ,IAAG;gBAAK,IAAG;YAAA,CAAK;SAAA;IAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/error-boundary/error-utils.tsx","file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/toast/toast-provider.tsx"],"sourcesContent":["import React, { useCallback } from \"react\";\nimport { GraphQLError } from \"@copilotkit/runtime-client-gql\";\nimport { useToast } from \"../toast/toast-provider\";\nimport { ExclamationMarkIcon } from \"../toast/exclamation-mark-icon\";\nimport ReactMarkdown from \"react-markdown\";\n\ninterface OriginalError {\n  message?: string;\n  stack?: string;\n}\n\nexport function ErrorToast({ errors }: { errors: (Error | GraphQLError)[] }) {\n  const errorsToRender = errors.map((error, idx) => {\n    const originalError =\n      \"extensions\" in error ? (error.extensions?.originalError as undefined | OriginalError) : {};\n    const message = originalError?.message ?? error.message;\n    const code = \"extensions\" in error ? (error.extensions?.code as string) : null;\n\n    return (\n      <div\n        key={idx}\n        style={{\n          marginTop: idx === 0 ? 0 : 10,\n          marginBottom: 14,\n        }}\n      >\n        <ExclamationMarkIcon style={{ marginBottom: 4 }} />\n\n        {code && (\n          <div\n            style={{\n              fontWeight: \"600\",\n              marginBottom: 4,\n            }}\n          >\n            Copilot Cloud Error:{\" \"}\n            <span style={{ fontFamily: \"monospace\", fontWeight: \"normal\" }}>{code}</span>\n          </div>\n        )}\n        <ReactMarkdown>{message}</ReactMarkdown>\n      </div>\n    );\n  });\n  return (\n    <div\n      style={{\n        fontSize: \"13px\",\n        maxWidth: \"600px\",\n      }}\n    >\n      {errorsToRender}\n      <div style={{ fontSize: \"11px\", opacity: 0.75 }}>\n        NOTE: This error only displays during local development.\n      </div>\n    </div>\n  );\n}\n\nexport function useErrorToast() {\n  const { addToast } = useToast();\n\n  return useCallback(\n    (error: (Error | GraphQLError)[]) => {\n      const errorId = error\n        .map((err) => {\n          const message =\n            \"extensions\" in err\n              ? (err.extensions?.originalError as any)?.message || err.message\n              : err.message;\n          const stack = err.stack || \"\";\n          return btoa(message + stack).slice(0, 32); // Create hash from message + stack\n        })\n        .join(\"|\");\n\n      addToast({\n        type: \"error\",\n        id: errorId, // Toast libraries typically dedupe by id\n        message: <ErrorToast errors={error} />,\n      });\n    },\n    [addToast],\n  );\n}\n\nexport function useAsyncCallback<T extends (...args: any[]) => Promise<any>>(\n  callback: T,\n  deps: Parameters<typeof useCallback>[1],\n) {\n  const addErrorToast = useErrorToast();\n  return useCallback(async (...args: Parameters<T>) => {\n    try {\n      return await callback(...args);\n    } catch (error) {\n      console.error(\"Error in async callback:\", error);\n      // @ts-ignore\n      addErrorToast([error]);\n      throw error;\n    }\n  }, deps);\n}\n","import { GraphQLError } from \"@copilotkit/runtime-client-gql\";\nimport React, { createContext, useContext, useState, useCallback } from \"react\";\nimport { ErrorToast } from \"../error-boundary/error-utils\";\nimport { PartialBy } from \"@copilotkit/shared\";\n\ninterface Toast {\n  id: string;\n  message: string | React.ReactNode;\n  type: \"info\" | \"success\" | \"warning\" | \"error\";\n  duration?: number;\n}\n\ninterface ToastContextValue {\n  toasts: Toast[];\n  addToast: (toast: PartialBy<Toast, \"id\">) => void;\n  addGraphQLErrorsToast: (errors: GraphQLError[]) => void;\n  removeToast: (id: string) => void;\n  enabled: boolean;\n}\n\nconst ToastContext = createContext<ToastContextValue | undefined>(undefined);\n\nexport function useToast() {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error(\"useToast must be used within a ToastProvider\");\n  }\n  return context;\n}\n\nexport function ToastProvider({\n  enabled,\n  children,\n}: {\n  enabled: boolean;\n  children: React.ReactNode;\n}) {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n  const addToast = useCallback(\n    (toast: PartialBy<Toast, \"id\">) => {\n      // We do not display these errors unless we are in dev mode.\n      if (!enabled) {\n        return;\n      }\n\n      const id = toast.id ?? Math.random().toString(36).substring(2, 9);\n\n      setToasts((currentToasts) => {\n        if (currentToasts.find((toast) => toast.id === id)) return currentToasts;\n        return [...currentToasts, { ...toast, id }];\n      });\n\n      if (toast.duration) {\n        setTimeout(() => {\n          removeToast(id);\n        }, toast.duration);\n      }\n    },\n    [enabled],\n  );\n\n  const addGraphQLErrorsToast = useCallback((errors: GraphQLError[]) => {\n    addToast({\n      type: \"error\",\n      message: <ErrorToast errors={errors} />,\n    });\n  }, []);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts((currentToasts) => currentToasts.filter((toast) => toast.id !== id));\n  }, []);\n\n  const value = {\n    toasts,\n    addToast,\n    addGraphQLErrorsToast,\n    removeToast,\n    enabled,\n  };\n\n  return (\n    <ToastContext.Provider value={value}>\n      <div\n        style={{\n          position: \"fixed\",\n          bottom: \"1rem\",\n          left: \"50%\",\n          transform: \"translateX(-50%)\",\n          zIndex: 50,\n          display: \"flex\",\n          flexDirection: \"column\",\n          gap: \"0.5rem\",\n        }}\n      >\n        {toasts.length > 1 && (\n          <div style={{ textAlign: \"right\" }}>\n            <button\n              onClick={() => setToasts([])}\n              style={{\n                padding: \"4px 8px\",\n                fontSize: \"12px\",\n                cursor: \"pointer\",\n                background: \"white\",\n                border: \"1px solid rgba(0,0,0,0.2)\",\n                borderRadius: \"4px\",\n              }}\n            >\n              Close All\n            </button>\n          </div>\n        )}\n        {toasts.map((toast) => (\n          <Toast\n            key={toast.id}\n            message={toast.message}\n            type={toast.type}\n            onClose={() => removeToast(toast.id)}\n          />\n        ))}\n      </div>\n      {children}\n    </ToastContext.Provider>\n  );\n}\n\nfunction Toast({\n  message,\n  type = \"info\",\n  onClose,\n}: {\n  message: string | React.ReactNode;\n  type: \"info\" | \"success\" | \"warning\" | \"error\";\n  onClose: () => void;\n}) {\n  const bgColors = {\n    info: \"#3b82f6\",\n    success: \"#22c55e\",\n    warning: \"#eab308\",\n    error: \"#ef4444\",\n  };\n\n  return (\n    <div\n      style={{\n        backgroundColor: bgColors[type],\n        color: \"white\",\n        padding: \"0.5rem 1.5rem\",\n        borderRadius: \"0.25rem\",\n        boxShadow: \"0 2px 4px rgba(0,0,0,0.1)\",\n        position: \"relative\",\n        minWidth: \"200px\",\n      }}\n    >\n      <div>{message}</div>\n      <button\n        onClick={onClose}\n        style={{\n          position: \"absolute\",\n          top: \"0\",\n          right: \"0\",\n          background: \"none\",\n          border: \"none\",\n          color: \"white\",\n          cursor: \"pointer\",\n          padding: \"0.5rem\",\n          fontSize: \"1rem\",\n        }}\n      >\n        âœ•\n      </button>\n    </div>\n  );\n}\n"],"names":["useCallback","toast","jsx","jsxs","useCallback"],"mappings":"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","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/error-boundary/error-boundary.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\nimport { Severity, CopilotKitError } from \"@copilotkit/shared\";\nimport { StatusChecker } from \"../../lib/status-checker\";\nimport { renderCopilotKitUsage, UsageBanner } from \"../usage-banner\";\nimport { useErrorToast } from \"./error-utils\";\nimport { COPILOT_CLOUD_ERROR_NAMES } from \"@copilotkit/shared\";\n\nconst statusChecker = new StatusChecker();\n\ninterface Props {\n  children: React.ReactNode;\n  publicApiKey?: string;\n  showUsageBanner?: boolean;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: CopilotKitError;\n  status?: {\n    severity: Severity;\n    message: string;\n  };\n}\n\nexport class CopilotErrorBoundary extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      hasError: false,\n    };\n  }\n\n  static getDerivedStateFromError(error: CopilotKitError): State {\n    return { hasError: true, error };\n  }\n\n  componentDidMount() {\n    if (this.props.publicApiKey) {\n      statusChecker.start(this.props.publicApiKey, (newStatus) => {\n        this.setState((prevState) => {\n          if (newStatus?.severity !== prevState.status?.severity) {\n            return { status: newStatus ?? undefined };\n          }\n          return null;\n        });\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    statusChecker.stop();\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error(\"CopilotKit Error:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      if (this.state.error instanceof CopilotKitError) {\n        // @ts-expect-error -- It's a copilotkit error at this state. Name is valid\n        if (COPILOT_CLOUD_ERROR_NAMES.includes(this.state.error.name)) {\n          return (\n            <ErrorToast error={this.state.error}>\n              {renderCopilotKitUsage(this.state.error)}\n            </ErrorToast>\n          );\n        }\n\n        return (\n          <>\n            {this.props.children}\n            {this.props.showUsageBanner && (\n              <UsageBanner\n                severity={this.state.status?.severity}\n                message={this.state.status?.message}\n              />\n            )}\n          </>\n        );\n      }\n      throw this.state.error;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport function ErrorToast({ error, children }: { error?: Error; children: React.ReactNode }) {\n  const addErrorToast = useErrorToast();\n\n  useEffect(() => {\n    if (error) {\n      addErrorToast([error]);\n    }\n  }, [error, addErrorToast]);\n\n  if (!error) throw error;\n  return children;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,SAAS,iBAAiB;AACjC,SAAmB,uBAAuB;AA8D9B,SAOF,UAPE,KAOF,YAPE;;;;;;;;AAxDZ,IAAM,gBAAgB,mLAAI,gBAAA,CAAc;AAiBjC,IAAM,uBAAN,4KAAmC,UAAA,CAAM,SAAA,CAAwB;IACtE,YAAY,KAAA,CAAc;QACxB,KAAA,CAAM,KAAK;QACX,IAAA,CAAK,KAAA,GAAQ;YACX,UAAU;QACZ;IACF;IAEA,OAAO,yBAAyB,KAAA,EAA+B;QAC7D,OAAO;YAAE,UAAU;YAAM;QAAM;IACjC;IAEA,oBAAoB;QAClB,IAAI,IAAA,CAAK,KAAA,CAAM,YAAA,EAAc;YAC3B,cAAc,KAAA,CAAM,IAAA,CAAK,KAAA,CAAM,YAAA,EAAc,CAAC,cAAc;gBAC1D,IAAA,CAAK,QAAA,CAAS,CAAC,cAAc;oBAvCrC,IAAA;oBAwCU,IAAA,CAAI,aAAA,OAAA,KAAA,IAAA,UAAW,QAAA,MAAA,CAAA,CAAa,KAAA,UAAU,MAAA,KAAV,OAAA,KAAA,IAAA,GAAkB,QAAA,GAAU;wBACtD,OAAO;4BAAE,QAAQ,aAAA,OAAA,YAAa,KAAA;wBAAU;oBAC1C;oBACA,OAAO;gBACT,CAAC;YACH,CAAC;QACH;IACF;IAEA,uBAAuB;QACrB,cAAc,IAAA,CAAK;IACrB;IAEA,kBAAkB,KAAA,EAAc,SAAA,EAA4B;QAC1D,QAAQ,KAAA,CAAM,qBAAqB,OAAO,SAAS;IACrD;IAEA,SAAS;QAzDX,IAAA,IAAA;QA0DI,IAAI,IAAA,CAAK,KAAA,CAAM,QAAA,EAAU;YACvB,IAAI,IAAA,CAAK,KAAA,CAAM,KAAA,oLAAiB,kBAAA,EAAiB;gBAE/C,4KAAI,4BAAA,CAA0B,QAAA,CAAS,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,IAAI,GAAG;oBAC7D,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,YAAA;wBAAW,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA;wBAC3B,UAAA,CAAA,GAAA,8KAAA,CAAA,wBAAA,EAAsB,IAAA,CAAK,KAAA,CAAM,KAAK;oBAAA,CACzC;gBAEJ;gBAEA,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAA,sKAAA,CAAA,WAAA,EAAA;oBACG,UAAA;wBAAA,IAAA,CAAK,KAAA,CAAM,QAAA;wBACX,IAAA,CAAK,KAAA,CAAM,eAAA,IACV,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,iLAAC,cAAA,EAAA;4BACC,UAAA,CAAU,KAAA,IAAA,CAAK,KAAA,CAAM,MAAA,KAAX,OAAA,KAAA,IAAA,GAAmB,QAAA;4BAC7B,SAAA,CAAS,KAAA,IAAA,CAAK,KAAA,CAAM,MAAA,KAAX,OAAA,KAAA,IAAA,GAAmB,OAAA;wBAAA;qBAC9B;gBAAA,CAEJ;YAEJ;YACA,MAAM,IAAA,CAAK,KAAA,CAAM,KAAA;QACnB;QAEA,OAAO,IAAA,CAAK,KAAA,CAAM,QAAA;IACpB;AACF;AAEO,SAAS,WAAW,EAAE,KAAA,EAAO,QAAA,CAAS,CAAA,EAAiD;IAC5F,MAAM,iBAAgB,kMAAA,CAAc;IAEpC,CAAA,GAAA,6JAAA,CAAA,YAAA;gCAAU,MAAM;YACd,IAAI,OAAO;gBACT,cAAc;oBAAC,KAAK;iBAAC;YACvB;QACF;+BAAG;QAAC;QAAO,aAAa;KAAC;IAEzB,IAAI,CAAC,OAAO,MAAM;IAClB,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/utils/dev-console.ts"],"sourcesContent":["export function shouldShowDevConsole(showDevConsole: boolean | \"auto\"): boolean {\n  if (typeof showDevConsole === \"boolean\") {\n    return showDevConsole;\n  }\n  return (\n    getHostname() === \"localhost\" ||\n    getHostname() === \"127.0.0.1\" ||\n    getHostname() === \"0.0.0.0\" ||\n    getHostname() === \"::1\"\n  );\n}\n\nfunction getHostname(): string {\n  if (typeof window !== \"undefined\" && window.location) {\n    return window.location.hostname;\n  }\n  return \"\";\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,qBAAqB,cAAA,EAA2C;IAC9E,IAAI,OAAO,mBAAmB,WAAW;QACvC,OAAO;IACT;IACA,OACE,YAAY,MAAM,eAClB,YAAY,MAAM,eAClB,YAAY,MAAM,aAClB,YAAY,MAAM;AAEtB;AAEA,SAAS,cAAsB;IAC7B,IAAI,OAAO,WAAW,eAAe,OAAO,QAAA,EAAU;QACpD,OAAO,OAAO,QAAA,CAAS,QAAA;IACzB;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 830, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 836, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/context/copilot-context.tsx"],"sourcesContent":["import { CopilotCloudConfig, FunctionCallHandler } from \"@copilotkit/shared\";\nimport {\n  ActionRenderProps,\n  CatchAllActionRenderProps,\n  FrontendAction,\n} from \"../types/frontend-action\";\nimport React from \"react\";\nimport { TreeNodeId } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\nimport { CopilotChatSuggestionConfiguration } from \"../types/chat-suggestion-configuration\";\nimport { CoAgentStateRender, CoAgentStateRenderProps } from \"../types/coagent-action\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport {\n  CopilotRuntimeClient,\n  ExtensionsInput,\n  ForwardedParametersInput,\n} from \"@copilotkit/runtime-client-gql\";\nimport { Agent } from \"@copilotkit/runtime-client-gql\";\nimport {\n  LangGraphInterruptAction,\n  LangGraphInterruptActionSetter,\n} from \"../types/interrupt-action\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The public API key for Copilot Cloud.\n   */\n  publicApiKey?: string;\n\n  /**\n   * The configuration for Copilot Cloud.\n   */\n  cloud?: CopilotCloudConfig;\n\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the Copilot transcribe audio service.\n   */\n  transcribeAudioUrl?: string;\n\n  /**\n   * The endpoint for the Copilot text to speech service.\n   */\n  textToSpeechUrl?: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Custom properties to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  properties?: Record<string, any>;\n\n  /**\n   * Indicates whether the user agent should send or receive cookies from the other domain\n   * in the case of cross-origin requests.\n   */\n  credentials?: RequestCredentials;\n}\n\nexport type InChatRenderFunction<TProps = ActionRenderProps<any> | CatchAllActionRenderProps<any>> =\n  (props: TProps) => string | JSX.Element;\nexport type CoagentInChatRenderFunction = (\n  props: CoAgentStateRenderProps<any>,\n) => string | JSX.Element | undefined | null;\n\nexport interface ChatComponentsCache {\n  actions: Record<string, InChatRenderFunction | string>;\n  coAgentStateRenders: Record<string, CoagentInChatRenderFunction | string>;\n}\n\nexport interface AgentSession {\n  agentName: string;\n  threadId?: string;\n  nodeName?: string;\n}\n\nexport interface AuthState {\n  status: \"authenticated\" | \"unauthenticated\";\n  authHeaders: Record<string, string>;\n  userId?: string;\n  metadata?: Record<string, any>;\n}\n\nexport type ActionName = string;\n\nexport interface CopilotContextParams {\n  // function-calling\n  actions: Record<string, FrontendAction<any>>;\n  setAction: (id: string, action: FrontendAction<any>) => void;\n  removeAction: (id: string) => void;\n\n  // coagent actions\n  coAgentStateRenders: Record<string, CoAgentStateRender<any>>;\n  setCoAgentStateRender: (id: string, stateRender: CoAgentStateRender<any>) => void;\n  removeCoAgentStateRender: (id: string) => void;\n\n  chatComponentsCache: React.RefObject<ChatComponentsCache>;\n\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  isLoading: boolean;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };\n  addChatSuggestionConfiguration: (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => void;\n  removeChatSuggestionConfiguration: (id: string) => void;\n\n  chatInstructions: string;\n  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;\n\n  additionalInstructions?: string[];\n  setAdditionalInstructions: React.Dispatch<React.SetStateAction<string[]>>;\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n\n  showDevConsole: boolean | \"auto\";\n\n  // agents\n  coagentStates: Record<string, CoagentState>;\n  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n  coagentStatesRef: React.RefObject<Record<string, CoagentState>>;\n  setCoagentStatesWithRef: (\n    value:\n      | Record<string, CoagentState>\n      | ((prev: Record<string, CoagentState>) => Record<string, CoagentState>),\n  ) => void;\n\n  agentSession: AgentSession | null;\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n\n  agentLock: string | null;\n\n  threadId: string;\n  setThreadId: React.Dispatch<React.SetStateAction<string>>;\n\n  runId: string | null;\n  setRunId: React.Dispatch<React.SetStateAction<string | null>>;\n\n  // The chat abort controller can be used to stop generation globally,\n  // i.e. when using `stop()` from `useChat`\n  chatAbortControllerRef: React.MutableRefObject<AbortController | null>;\n\n  // runtime\n  runtimeClient: CopilotRuntimeClient;\n\n  /**\n   * The forwarded parameters to use for the task.\n   */\n  forwardedParameters?: Pick<ForwardedParametersInput, \"temperature\">;\n  availableAgents: Agent[];\n\n  /**\n   * The auth states for the CopilotKit.\n   */\n  authStates_c?: Record<ActionName, AuthState>;\n  setAuthStates_c?: React.Dispatch<React.SetStateAction<Record<ActionName, AuthState>>>;\n\n  /**\n   * The auth config for the CopilotKit.\n   */\n  authConfig_c?: {\n    SignInComponent: React.ComponentType<{\n      onSignInComplete: (authState: AuthState) => void;\n    }>;\n  };\n\n  extensions: ExtensionsInput;\n  setExtensions: React.Dispatch<React.SetStateAction<ExtensionsInput>>;\n  langGraphInterruptAction: LangGraphInterruptAction | null;\n  setLangGraphInterruptAction: LangGraphInterruptActionSetter;\n  removeLangGraphInterruptAction: () => void;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  actions: {},\n  setAction: () => {},\n  removeAction: () => {},\n\n  coAgentStateRenders: {},\n  setCoAgentStateRender: () => {},\n  removeCoAgentStateRender: () => {},\n\n  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  isLoading: false,\n  setIsLoading: () => returnAndThrowInDebug(false),\n\n  chatInstructions: \"\",\n  setChatInstructions: () => returnAndThrowInDebug(\"\"),\n\n  additionalInstructions: [],\n  setAdditionalInstructions: () => returnAndThrowInDebug([]),\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n  runtimeClient: {} as any,\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n\n  chatSuggestionConfiguration: {},\n  addChatSuggestionConfiguration: () => {},\n  removeChatSuggestionConfiguration: () => {},\n  showDevConsole: \"auto\",\n  coagentStates: {},\n  setCoagentStates: () => {},\n  coagentStatesRef: { current: {} },\n  setCoagentStatesWithRef: () => {},\n  agentSession: null,\n  setAgentSession: () => {},\n  forwardedParameters: {},\n  agentLock: null,\n  threadId: \"\",\n  setThreadId: () => {},\n  runId: null,\n  setRunId: () => {},\n  chatAbortControllerRef: { current: null },\n  availableAgents: [],\n  extensions: {},\n  setExtensions: () => {},\n  langGraphInterruptAction: null,\n  setLangGraphInterruptAction: () => null,\n  removeLangGraphInterruptAction: () => null,\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  const context = React.useContext(CopilotContext);\n  if (context === emptyCopilotContext) {\n    throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  }\n  return context;\n}\n\nfunction returnAndThrowInDebug<T>(_value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n}\n"],"names":[],"mappings":";;;;;;AAMA,OAAO,WAAW;;;AA+MlB,IAAM,sBAA4C;IAChD,SAAS,CAAC;IACV,WAAW,KAAO,CAAD;IACjB,cAAc,KAAO,CAAD;IAEpB,qBAAqB,CAAC;IACtB,uBAAuB,KAAO,CAAD;IAC7B,0BAA0B,KAAO,CAAD;IAEhC,qBAAqB;QAAE,SAAS;YAAE,SAAS,CAAC;YAAG,qBAAqB,CAAC;QAAE;IAAE;IACzE,kBAAkB,CAAC,WAA8B,aAC/C,sBAAsB,EAAE;IAC1B,YAAY,IAAM;IAClB,eAAe,KAAO,CAAD;IAErB,wBAAwB,IAAM,sBAAsB,uLAAY,UAAA,EAAA,KAAA,GAAA,MAAA,aAAC,EAAC;IAElE,WAAW;IACX,cAAc,IAAM,sBAAsB,KAAK;IAE/C,kBAAkB;IAClB,qBAAqB,IAAM,sBAAsB,EAAE;IAEnD,wBAAwB,CAAC,CAAA;IACzB,2BAA2B,IAAM,sBAAsB,CAAC,CAAC;IAEzD,qBAAqB,CAAC,aAAyB,sBAAsB,CAAC,CAAC;IACvE,oBAAoB,IAAM,sBAAsB,EAAE;IAClD,uBAAuB,KAAO,CAAD;IAC7B,eAAe,CAAC;IAEhB,kBAAkB,IAAK,MAAkC;QACvD,IAAI,kBAA0B;YAC5B,MAAM,IAAI,MAAM,uEAAuE;QACzF;QAEA,IAAI,UAAkC;YACpC,OAAO,CAAC;QACV;QACA,IAAI,OAA4B;YAC9B,OAAO,CAAC;QACV;IACF,EAAG;IAEH,6BAA6B,CAAC;IAC9B,gCAAgC,KAAO,CAAD;IACtC,mCAAmC,KAAO,CAAD;IACzC,gBAAgB;IAChB,eAAe,CAAC;IAChB,kBAAkB,KAAO,CAAD;IACxB,kBAAkB;QAAE,SAAS,CAAC;IAAE;IAChC,yBAAyB,KAAO,CAAD;IAC/B,cAAc;IACd,iBAAiB,KAAO,CAAD;IACvB,qBAAqB,CAAC;IACtB,WAAW;IACX,UAAU;IACV,aAAa,KAAO,CAAD;IACnB,OAAO;IACP,UAAU,KAAO,CAAD;IAChB,wBAAwB;QAAE,SAAS;IAAK;IACxC,iBAAiB,CAAC,CAAA;IAClB,YAAY,CAAC;IACb,eAAe,KAAO,CAAD;IACrB,0BAA0B;IAC1B,6BAA6B,IAAM;IACnC,gCAAgC,IAAM;AACxC;AAEO,IAAM,+KAAiB,UAAA,CAAM,aAAA,CAAoC,mBAAmB;AAEpF,SAAS,oBAA0C;IACxD,MAAM,wKAAU,UAAA,CAAM,UAAA,CAAW,cAAc;IAC/C,IAAI,YAAY,qBAAqB;QACnC,MAAM,IAAI,MAAM,uEAAuE;IACzF;IACA,OAAO;AACT;AAEA,SAAS,sBAAyB,MAAA,EAAc;IAC9C,MAAM,IAAI,MAAM,uEAAuE;AACzF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 924, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 930, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/context/copilot-messages-context.tsx"],"sourcesContent":["/**\n * An internal context to separate the messages state (which is constantly changing) from the rest of CopilotKit context\n */\n\nimport { Message } from \"@copilotkit/runtime-client-gql\";\nimport React from \"react\";\n\nexport interface CopilotMessagesContextParams {\n  messages: Message[];\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n}\n\nconst emptyCopilotContext: CopilotMessagesContextParams = {\n  messages: [],\n  setMessages: () => [],\n};\n\nexport const CopilotMessagesContext =\n  React.createContext<CopilotMessagesContextParams>(emptyCopilotContext);\n\nexport function useCopilotMessagesContext(): CopilotMessagesContextParams {\n  const context = React.useContext(CopilotMessagesContext);\n  if (context === emptyCopilotContext) {\n    throw new Error(\n      \"A messages consuming component was not wrapped with `<CopilotMessages> {...} </CopilotMessages>`\",\n    );\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;AAKA,OAAO,WAAW;;AAOlB,IAAM,sBAAoD;IACxD,UAAU,CAAC,CAAA;IACX,aAAa,IAAM,CAAC,CAAA;AACtB;AAEO,IAAM,uLACX,UAAA,CAAM,aAAA,CAA4C,mBAAmB;AAEhE,SAAS,4BAA0D;IACxE,MAAM,wKAAU,UAAA,CAAM,UAAA,CAAW,sBAAsB;IACvD,IAAI,YAAY,qBAAqB;QACnC,MAAM,IAAI,MACR;IAEJ;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/copilot-provider/copilot-messages.tsx"],"sourcesContent":["/**\n * An internal context to separate the messages state (which is constantly changing) from the rest of CopilotKit context\n */\n\nimport { ReactNode, useEffect, useState, useRef } from \"react\";\nimport { CopilotMessagesContext } from \"../../context/copilot-messages-context\";\nimport { loadMessagesFromJsonRepresentation, Message } from \"@copilotkit/runtime-client-gql\";\nimport { useCopilotContext } from \"../../context/copilot-context\";\n\nexport function CopilotMessages({ children }: { children: ReactNode }) {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const lastLoadedThreadId = useRef<string>();\n  const lastLoadedAgentName = useRef<string>();\n  const lastLoadedMessages = useRef<string>();\n\n  const { threadId, agentSession, runtimeClient } = useCopilotContext();\n\n  useEffect(() => {\n    if (!threadId || threadId === lastLoadedThreadId.current) return;\n    if (\n      threadId === lastLoadedThreadId.current &&\n      agentSession?.agentName === lastLoadedAgentName.current\n    ) {\n      return;\n    }\n\n    const fetchMessages = async () => {\n      if (!agentSession?.agentName) return;\n\n      const result = await runtimeClient.loadAgentState({\n        threadId,\n        agentName: agentSession?.agentName,\n      });\n\n      const newMessages = result.data?.loadAgentState?.messages;\n      if (newMessages === lastLoadedMessages.current) return;\n\n      if (result.data?.loadAgentState?.threadExists) {\n        lastLoadedMessages.current = newMessages;\n        lastLoadedThreadId.current = threadId;\n        lastLoadedAgentName.current = agentSession?.agentName;\n\n        const messages = loadMessagesFromJsonRepresentation(JSON.parse(newMessages || \"[]\"));\n        setMessages(messages);\n      }\n    };\n    void fetchMessages();\n  }, [threadId, agentSession?.agentName]);\n\n  return (\n    <CopilotMessagesContext.Provider\n      value={{\n        messages,\n        setMessages,\n      }}\n    >\n      {children}\n    </CopilotMessagesContext.Provider>\n  );\n}\n"],"names":["messages"],"mappings":";;;;;;;AAIA,SAAoB,WAAW,UAAU,cAAc;AAEvD,SAAS,0CAAmD;AA4CxD;;;;;;;AAzCG,SAAS,gBAAgB,EAAE,QAAA,CAAS,CAAA,EAA4B;IACrE,MAAM,CAAC,UAAU,WAAW,CAAA,oKAAI,YAAA,EAAoB,CAAC,CAAC;IACtD,MAAM,uLAAqB,SAAA,CAAe;IAC1C,MAAM,wLAAsB,SAAA,CAAe;IAC3C,MAAM,qBAAqB,2KAAA,CAAe;IAE1C,MAAM,EAAE,QAAA,EAAU,YAAA,EAAc,aAAA,CAAc,CAAA,OAAI,mMAAA,CAAkB;IAEpE,CAAA,GAAA,6JAAA,CAAA,YAAA;qCAAU,MAAM;YACd,IAAI,CAAC,YAAY,aAAa,mBAAmB,OAAA,EAAS;YAC1D,IACE,aAAa,mBAAmB,OAAA,IAAA,CAChC,gBAAA,OAAA,KAAA,IAAA,aAAc,SAAA,MAAc,oBAAoB,OAAA,EAChD;gBACA;YACF;YAEA,MAAM;2DAAgB,uLAAY,UAAA,EAAA,IAAA,EAAA;mEAAA;4BA1BtC,IAAA,IAAA,IAAA,IAAA;4BA2BM,IAAI,CAAA,CAAC,gBAAA,OAAA,KAAA,IAAA,aAAc,SAAA,GAAW;4BAE9B,MAAM,SAAS,MAAM,cAAc,cAAA,CAAe;gCAChD;gCACA,WAAW,gBAAA,OAAA,KAAA,IAAA,aAAc,SAAA;4BAC3B,CAAC;4BAED,MAAM,cAAA,CAAc,KAAA,CAAA,KAAA,OAAO,IAAA,KAAP,OAAA,KAAA,IAAA,GAAa,cAAA,KAAb,OAAA,KAAA,IAAA,GAA6B,QAAA;4BACjD,IAAI,gBAAgB,mBAAmB,OAAA,EAAS;4BAEhD,IAAA,CAAI,KAAA,CAAA,KAAA,OAAO,IAAA,KAAP,OAAA,KAAA,IAAA,GAAa,cAAA,KAAb,OAAA,KAAA,IAAA,GAA6B,YAAA,EAAc;gCAC7C,mBAAmB,OAAA,GAAU;gCAC7B,mBAAmB,OAAA,GAAU;gCAC7B,oBAAoB,OAAA,GAAU,gBAAA,OAAA,KAAA,IAAA,aAAc,SAAA;gCAE5C,MAAMA,0MAAW,qCAAA,EAAmC,KAAK,KAAA,CAAM,eAAe,IAAI,CAAC;gCACnF,YAAYA,SAAQ;4BACtB;wBACF;;;YACA,KAAK,cAAc;QACrB;oCAAG;QAAC;QAAU,gBAAA,OAAA,KAAA,IAAA,aAAc,SAAS;KAAC;IAEtC,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,iLAAC,yBAAA,CAAuB,QAAA,EAAvB;QACC,OAAO;YACL;YACA;QACF;QAEC;IAAA;AAGP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1022, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1028, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-flat-category-store.ts"],"sourcesContent":["import { useCallback, useReducer } from \"react\";\nimport { randomId } from \"@copilotkit/shared\";\n\nexport type FlatCategoryStoreId = string;\n\nexport interface UseFlatCategoryStoreReturn<T> {\n  addElement: (value: T, categories: string[]) => FlatCategoryStoreId;\n  removeElement: (id: FlatCategoryStoreId) => void;\n  allElements: (categories: string[]) => T[];\n}\n\ninterface FlatCategoryStoreElement<T> {\n  id: FlatCategoryStoreId;\n  value: T;\n  categories: Set<string>;\n}\n\nconst useFlatCategoryStore = <T>(): UseFlatCategoryStoreReturn<T> => {\n  const [elements, dispatch] = useReducer<\n    React.Reducer<Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>, Action<T>>\n  >(flatCategoryStoreReducer, new Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>());\n\n  const addElement = useCallback((value: T, categories: string[]): FlatCategoryStoreId => {\n    const newId = randomId();\n    dispatch({\n      type: \"ADD_ELEMENT\",\n      value,\n      id: newId,\n      categories,\n    });\n    return newId;\n  }, []);\n\n  const removeElement = useCallback((id: FlatCategoryStoreId): void => {\n    dispatch({ type: \"REMOVE_ELEMENT\", id });\n  }, []);\n\n  const allElements = useCallback(\n    (categories: string[]): T[] => {\n      const categoriesSet = new Set(categories);\n      const result: T[] = [];\n      elements.forEach((element) => {\n        if (setsHaveIntersection(categoriesSet, element.categories)) {\n          result.push(element.value);\n        }\n      });\n      return result;\n    },\n    [elements],\n  );\n\n  return { addElement, removeElement, allElements };\n};\n\nexport default useFlatCategoryStore;\n\n// Action types\ntype Action<T> =\n  | {\n      type: \"ADD_ELEMENT\";\n      value: T;\n      id: FlatCategoryStoreId;\n      categories: string[];\n    }\n  | { type: \"REMOVE_ELEMENT\"; id: FlatCategoryStoreId };\n\n// Reducer\nfunction flatCategoryStoreReducer<T>(\n  state: Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>,\n  action: Action<T>,\n): Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>> {\n  switch (action.type) {\n    case \"ADD_ELEMENT\": {\n      const { value, id, categories } = action;\n      const newElement: FlatCategoryStoreElement<T> = {\n        id,\n        value,\n        categories: new Set(categories),\n      };\n      const newState = new Map(state);\n      newState.set(id, newElement);\n      return newState;\n    }\n    case \"REMOVE_ELEMENT\": {\n      const newState = new Map(state);\n      newState.delete(action.id);\n      return newState;\n    }\n    default:\n      return state;\n  }\n}\n\nfunction setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {\n  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];\n\n  for (let item of smallerSet) {\n    if (largerSet.has(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa,kBAAkB;AACxC,SAAS,gBAAgB;;;AAgBzB,IAAM,uBAAuB,MAAwC;IACnE,MAAM,CAAC,UAAU,QAAQ,CAAA,qKAAI,aAAA,EAE3B,0BAA0B,aAAA,GAAA,IAAI,IAAsD,CAAC;IAEvF,MAAM,+KAAa,cAAA;wDAAY,CAAC,OAAU,eAA8C;YACtF,MAAM,YAAQ,mLAAA,CAAS;YACvB,SAAS;gBACP,MAAM;gBACN;gBACA,IAAI;gBACJ;YACF,CAAC;YACD,OAAO;QACT;uDAAG,CAAC,CAAC;IAEL,MAAM,kLAAgB,cAAA;2DAAY,CAAC,OAAkC;YACnE,SAAS;gBAAE,MAAM;gBAAkB;YAAG,CAAC;QACzC;0DAAG,CAAC,CAAC;IAEL,MAAM,gLAAc,cAAA;yDAClB,CAAC,eAA8B;YAC7B,MAAM,gBAAgB,IAAI,IAAI,UAAU;YACxC,MAAM,SAAc,CAAC,CAAA;YACrB,SAAS,OAAA;iEAAQ,CAAC,YAAY;oBAC5B,IAAI,qBAAqB,eAAe,QAAQ,UAAU,GAAG;wBAC3D,OAAO,IAAA,CAAK,QAAQ,KAAK;oBAC3B;gBACF,CAAC;;YACD,OAAO;QACT;wDACA;QAAC,QAAQ;KAAA;IAGX,OAAO;QAAE;QAAY;QAAe;IAAY;AAClD;AAEA,IAAO,kCAAQ;AAaf,SAAS,yBACP,KAAA,EACA,MAAA,EACuD;IACvD,OAAQ,OAAO,IAAA,EAAM;QACnB,KAAK;YAAe;gBAClB,MAAM,EAAE,KAAA,EAAO,EAAA,EAAI,UAAA,CAAW,CAAA,GAAI;gBAClC,MAAM,aAA0C;oBAC9C;oBACA;oBACA,YAAY,IAAI,IAAI,UAAU;gBAChC;gBACA,MAAM,WAAW,IAAI,IAAI,KAAK;gBAC9B,SAAS,GAAA,CAAI,IAAI,UAAU;gBAC3B,OAAO;YACT;QACA,KAAK;YAAkB;gBACrB,MAAM,WAAW,IAAI,IAAI,KAAK;gBAC9B,SAAS,MAAA,CAAO,OAAO,EAAE;gBACzB,OAAO;YACT;QACA;YACE,OAAO;IACX;AACF;AAEA,SAAS,qBAAwB,IAAA,EAAc,IAAA,EAAuB;IACpE,MAAM,CAAC,YAAY,SAAS,CAAA,GAAI,KAAK,IAAA,IAAQ,KAAK,IAAA,GAAO;QAAC;QAAM,IAAI;KAAA,GAAI;QAAC;QAAM,IAAI;KAAA;IAEnF,KAAA,IAAS,QAAQ,WAAY;QAC3B,IAAI,UAAU,GAAA,CAAI,IAAI,GAAG;YACvB,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1122, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1128, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-tree.ts"],"sourcesContent":["import { randomId } from \"@copilotkit/shared\";\nimport { useCallback, useReducer } from \"react\";\n\nexport type TreeNodeId = string;\n\nexport interface TreeNode {\n  id: TreeNodeId;\n  value: string;\n  children: TreeNode[];\n  parentId?: TreeNodeId;\n  categories: Set<string>;\n}\n\nexport type Tree = TreeNode[];\n\nexport interface UseTreeReturn {\n  tree: Tree;\n  addElement: (value: string, categories: string[], parentId?: TreeNodeId) => TreeNodeId;\n  printTree: (categories: string[]) => string;\n  removeElement: (id: TreeNodeId) => void;\n}\n\nconst findNode = (nodes: Tree, id: TreeNodeId): TreeNode | undefined => {\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n    const result = findNode(node.children, id);\n    if (result) {\n      return result;\n    }\n  }\n  return undefined;\n};\n\nconst removeNode = (nodes: Tree, id: TreeNodeId): Tree => {\n  return nodes.reduce((result: Tree, node) => {\n    if (node.id !== id) {\n      const newNode = { ...node, children: removeNode(node.children, id) };\n      result.push(newNode);\n    }\n    return result;\n  }, []);\n};\n\nconst addNode = (nodes: Tree, newNode: TreeNode, parentId?: TreeNodeId): Tree => {\n  if (!parentId) {\n    return [...nodes, newNode];\n  }\n  return nodes.map((node) => {\n    if (node.id === parentId) {\n      return { ...node, children: [...node.children, newNode] };\n    } else if (node.children.length) {\n      return { ...node, children: addNode(node.children, newNode, parentId) };\n    }\n    return node;\n  });\n};\n\nconst treeIndentationRepresentation = (index: number, indentLevel: number): string => {\n  if (indentLevel === 0) {\n    return (index + 1).toString();\n  } else if (indentLevel === 1) {\n    return String.fromCharCode(65 + index); // 65 is the ASCII value for 'A'\n  } else if (indentLevel === 2) {\n    return String.fromCharCode(97 + index); // 97 is the ASCII value for 'a'\n  } else {\n    return \"-\";\n  }\n};\n\nconst printNode = (node: TreeNode, prefix = \"\", indentLevel = 0): string => {\n  const indent = \" \".repeat(3).repeat(indentLevel);\n\n  const prefixPlusIndentLength = prefix.length + indent.length;\n  const subsequentLinesPrefix = \" \".repeat(prefixPlusIndentLength);\n\n  const valueLines = node.value.split(\"\\n\");\n\n  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;\n  const outputSubsequentLines = valueLines\n    .slice(1)\n    .map((line) => `${subsequentLinesPrefix}${line}`)\n    .join(\"\\n\");\n\n  let output = `${outputFirstLine}\\n`;\n  if (outputSubsequentLines) {\n    output += `${outputSubsequentLines}\\n`;\n  }\n\n  const childPrePrefix = \" \".repeat(prefix.length);\n\n  node.children.forEach(\n    (child, index) =>\n      (output += printNode(\n        child,\n        `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,\n        indentLevel + 1,\n      )),\n  );\n  return output;\n};\n\n// Action types\ntype Action =\n  | {\n      type: \"ADD_NODE\";\n      value: string;\n      parentId?: string;\n      id: string;\n      categories: string[];\n    }\n  | { type: \"REMOVE_NODE\"; id: string };\n\n// Reducer function\nfunction treeReducer(state: Tree, action: Action): Tree {\n  switch (action.type) {\n    case \"ADD_NODE\": {\n      const { value, parentId, id: newNodeId } = action;\n      const newNode: TreeNode = {\n        id: newNodeId,\n        value,\n        children: [],\n        categories: new Set(action.categories),\n      };\n\n      try {\n        return addNode(state, newNode, parentId);\n      } catch (error) {\n        console.error(`Error while adding node with id ${newNodeId}: ${error}`);\n        return state;\n      }\n    }\n    case \"REMOVE_NODE\":\n      return removeNode(state, action.id);\n    default:\n      return state;\n  }\n}\n\n// useTree hook\nconst useTree = (): UseTreeReturn => {\n  const [tree, dispatch] = useReducer(treeReducer, []);\n\n  const addElement = useCallback(\n    (value: string, categories: string[], parentId?: string): TreeNodeId => {\n      const newNodeId = randomId(); // Generate new ID outside of dispatch\n      dispatch({\n        type: \"ADD_NODE\",\n        value,\n        parentId,\n        id: newNodeId,\n        categories: categories,\n      });\n      return newNodeId; // Return the new ID\n    },\n    [],\n  );\n\n  const removeElement = useCallback((id: TreeNodeId): void => {\n    dispatch({ type: \"REMOVE_NODE\", id });\n  }, []);\n\n  const printTree = useCallback(\n    (categories: string[]): string => {\n      const categoriesSet = new Set(categories);\n\n      let output = \"\";\n      tree.forEach((node, index) => {\n        // if the node does not have any of the desired categories, continue to the next node\n        if (!setsHaveIntersection(categoriesSet, node.categories)) {\n          return;\n        }\n\n        // add a new line before each node except the first one\n        if (index !== 0) {\n          output += \"\\n\";\n        }\n\n        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);\n      });\n      return output;\n    },\n    [tree],\n  );\n\n  return { tree, addElement, printTree, removeElement };\n};\n\nexport default useTree;\n\nfunction setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {\n  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];\n\n  for (let item of smallerSet) {\n    if (largerSet.has(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1292, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1298, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-copilot-runtime-client.ts"],"sourcesContent":["import {\n  CopilotRuntimeClient,\n  CopilotRuntimeClientOptions,\n  GraphQLError,\n} from \"@copilotkit/runtime-client-gql\";\nimport { useToast } from \"../components/toast/toast-provider\";\nimport { useMemo } from \"react\";\nimport { useErrorToast } from \"../components/error-boundary/error-utils\";\n\nexport const useCopilotRuntimeClient = (options: CopilotRuntimeClientOptions) => {\n  const { addGraphQLErrorsToast } = useToast();\n  const addErrorToast = useErrorToast();\n  const { addToast } = useToast();\n\n  const runtimeClient = useMemo(() => {\n    return new CopilotRuntimeClient({\n      ...options,\n      handleGQLErrors: (error) => {\n        if ((error as any).graphQLErrors.length) {\n          addGraphQLErrorsToast((error as any).graphQLErrors as GraphQLError[]);\n        } else {\n          addErrorToast([error]);\n        }\n      },\n      handleGQLWarning: (message: string) => {\n        console.warn(message);\n        addToast({ type: \"warning\", message });\n      },\n    });\n  }, [options, addGraphQLErrorsToast, addToast]);\n\n  return runtimeClient;\n};\n"],"names":[],"mappings":";;;;;;AAAA;AAMA,SAAS,eAAe;;;;;AAGjB,IAAM,0BAA0B,CAAC,YAAyC;IAC/E,MAAM,EAAE,qBAAA,CAAsB,CAAA,OAAI,0LAAA,CAAS;IAC3C,MAAM,mMAAgB,gBAAA,CAAc;IACpC,MAAM,EAAE,QAAA,CAAS,CAAA,IAAI,6LAAA,CAAS;IAE9B,MAAM,kLAAgB,UAAA;0DAAQ,MAAM;YAClC,OAAO,8LAAI,uBAAA,oLAAqB,gBAAA,EAAA,CAAA,GAAA,8KAAA,CAAA,iBAAA,EAAA,CAAA,GAC3B,UAD2B;gBAE9B,eAAA;sEAAiB,CAAC,UAAU;wBAC1B,IAAK,MAAc,aAAA,CAAc,MAAA,EAAQ;4BACvC,sBAAuB,MAAc,aAA+B;wBACtE,OAAO;4BACL,cAAc;gCAAC,KAAK;6BAAC;wBACvB;oBACF;;gBACA,gBAAA;sEAAkB,CAAC,YAAoB;wBACrC,QAAQ,IAAA,CAAK,OAAO;wBACpB,SAAS;4BAAE,MAAM;4BAAW;wBAAQ,CAAC;oBACvC;;YACF,EAAC;QACH;yDAAG;QAAC;QAAS;QAAuB,QAAQ;KAAC;IAE7C,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1348, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1354, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/utils/extract.ts","file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/components/copilot-provider/copilotkit.tsx"],"sourcesContent":["import {\n  Action,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  MappedParameterTypes,\n  Parameter,\n  actionParametersToJsonSchema,\n} from \"@copilotkit/shared\";\nimport {\n  ActionExecutionMessage,\n  Message,\n  Role,\n  TextMessage,\n  convertGqlOutputToMessages,\n  CopilotRequestType,\n  ForwardedParametersInput,\n} from \"@copilotkit/runtime-client-gql\";\nimport { CopilotContextParams, CopilotMessagesContextParams } from \"../context\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { CopilotRuntimeClient } from \"@copilotkit/runtime-client-gql\";\nimport {\n  convertMessagesToGqlInput,\n  filterAgentStateMessages,\n} from \"@copilotkit/runtime-client-gql\";\n\ninterface InitialState<T extends Parameter[] | [] = []> {\n  status: \"initial\";\n  args: Partial<MappedParameterTypes<T>>;\n}\n\ninterface InProgressState<T extends Parameter[] | [] = []> {\n  status: \"inProgress\";\n  args: Partial<MappedParameterTypes<T>>;\n}\n\ninterface CompleteState<T extends Parameter[] | [] = []> {\n  status: \"complete\";\n  args: MappedParameterTypes<T>;\n}\n\ntype StreamHandlerArgs<T extends Parameter[] | [] = []> =\n  | InitialState<T>\n  | InProgressState<T>\n  | CompleteState<T>;\n\ninterface ExtractOptions<T extends Parameter[]> {\n  context: CopilotContextParams & CopilotMessagesContextParams;\n  instructions: string;\n  parameters: T;\n  include?: IncludeOptions;\n  data?: any;\n  abortSignal?: AbortSignal;\n  stream?: (args: StreamHandlerArgs<T>) => void;\n  requestType?: CopilotRequestType;\n  forwardedParameters?: ForwardedParametersInput;\n}\n\ninterface IncludeOptions {\n  readable?: boolean;\n  messages?: boolean;\n}\n\nexport async function extract<const T extends Parameter[]>({\n  context,\n  instructions,\n  parameters,\n  include,\n  data,\n  abortSignal,\n  stream,\n  requestType = CopilotRequestType.Task,\n  forwardedParameters,\n}: ExtractOptions<T>): Promise<MappedParameterTypes<T>> {\n  const { messages } = context;\n\n  const action: Action<any> = {\n    name: \"extract\",\n    description: instructions,\n    parameters,\n    handler: (args: any) => {},\n  };\n\n  const includeReadable = include?.readable ?? false;\n  const includeMessages = include?.messages ?? false;\n\n  let contextString = \"\";\n\n  if (data) {\n    contextString = (typeof data === \"string\" ? data : JSON.stringify(data)) + \"\\n\\n\";\n  }\n\n  if (includeReadable) {\n    contextString += context.getContextString([], defaultCopilotContextCategories);\n  }\n\n  const systemMessage: Message = new TextMessage({\n    content: makeSystemMessage(contextString, instructions),\n    role: Role.System,\n  });\n\n  const instructionsMessage: Message = new TextMessage({\n    content: makeInstructionsMessage(instructions),\n    role: Role.User,\n  });\n\n  const response = context.runtimeClient.asStream(\n    context.runtimeClient.generateCopilotResponse({\n      data: {\n        frontend: {\n          actions: [\n            {\n              name: action.name,\n              description: action.description || \"\",\n              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n            },\n          ],\n          url: window.location.href,\n        },\n\n        messages: convertMessagesToGqlInput(\n          includeMessages\n            ? [systemMessage, instructionsMessage, ...filterAgentStateMessages(messages)]\n            : [systemMessage, instructionsMessage],\n        ),\n        metadata: {\n          requestType: requestType,\n        },\n        forwardedParameters: {\n          ...(forwardedParameters ?? {}),\n          toolChoice: \"function\",\n          toolChoiceFunctionName: action.name,\n        },\n      },\n      properties: context.copilotApiConfig.properties,\n      signal: abortSignal,\n    }),\n  );\n\n  const reader = response.getReader();\n\n  let isInitial = true;\n\n  let actionExecutionMessage: ActionExecutionMessage | undefined = undefined;\n\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      break;\n    }\n\n    if (abortSignal?.aborted) {\n      throw new Error(\"Aborted\");\n    }\n\n    actionExecutionMessage = convertGqlOutputToMessages(\n      value.generateCopilotResponse.messages,\n    ).find((msg) => msg.isActionExecutionMessage()) as ActionExecutionMessage | undefined;\n\n    if (!actionExecutionMessage) {\n      continue;\n    }\n\n    stream?.({\n      status: isInitial ? \"initial\" : \"inProgress\",\n      args: actionExecutionMessage.arguments as Partial<MappedParameterTypes<T>>,\n    });\n\n    isInitial = false;\n  }\n\n  if (!actionExecutionMessage) {\n    throw new Error(\"extract() failed: No function call occurred\");\n  }\n\n  stream?.({\n    status: \"complete\",\n    args: actionExecutionMessage.arguments as MappedParameterTypes<T>,\n  });\n\n  return actionExecutionMessage.arguments as MappedParameterTypes<T>;\n}\n\n// We need to put this in a user message since some LLMs need\n// at least one user message to function\nfunction makeInstructionsMessage(instructions: string): string {\n  return `\nThe user has given you the following task to complete:\n\n\\`\\`\\`\n${instructions}\n\\`\\`\\`\n\nAny additional messages provided are for providing context only and should not be used to ask questions or engage in conversation.\n`;\n}\n\nfunction makeSystemMessage(contextString: string, instructions: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with a function called extract you MUST call to initiate actions on their behalf.\n\nPlease assist them as best you can.\n\nThis is not a conversation, so please do not ask questions. Just call the function without saying anything else.\n`;\n}\n","/**\n * This component will typically wrap your entire application (or a sub-tree of your application where you want to have a copilot). It provides the copilot context to all other components and hooks.\n *\n * ## Example\n *\n * You can find more information about self-hosting CopilotKit [here](/guides/self-hosting).\n *\n * ```tsx\n * import { CopilotKit } from \"@copilotkit/react-core\";\n *\n * <CopilotKit runtimeUrl=\"<your-runtime-url>\">\n *   // ... your app ...\n * </CopilotKit>\n * ```\n */\n\nimport { useCallback, useEffect, useMemo, useRef, useState, SetStateAction } from \"react\";\nimport {\n  CopilotContext,\n  CopilotApiConfig,\n  ChatComponentsCache,\n  AgentSession,\n  AuthState,\n} from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { CopilotChatSuggestionConfiguration, DocumentPointer } from \"../../types\";\nimport { flushSync } from \"react-dom\";\nimport {\n  COPILOT_CLOUD_CHAT_URL,\n  CopilotCloudConfig,\n  FunctionCallHandler,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  randomUUID,\n  ConfigurationError,\n  MissingPublicApiKeyError,\n} from \"@copilotkit/shared\";\nimport { FrontendAction } from \"../../types/frontend-action\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { CoAgentStateRender } from \"../../types/coagent-action\";\nimport { CoagentState } from \"../../types/coagent-state\";\nimport { CopilotMessages } from \"./copilot-messages\";\nimport { ToastProvider } from \"../toast/toast-provider\";\nimport { useCopilotRuntimeClient } from \"../../hooks/use-copilot-runtime-client\";\nimport { shouldShowDevConsole } from \"../../utils\";\nimport { CopilotErrorBoundary } from \"../error-boundary/error-boundary\";\nimport { Agent, ExtensionsInput } from \"@copilotkit/runtime-client-gql\";\nimport {\n  LangGraphInterruptAction,\n  LangGraphInterruptActionSetterArgs,\n} from \"../../types/interrupt-action\";\n\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  const showDevConsole = props.showDevConsole === undefined ? \"auto\" : props.showDevConsole;\n  const enabled = shouldShowDevConsole(showDevConsole);\n\n  return (\n    <ToastProvider enabled={enabled}>\n      <CopilotErrorBoundary publicApiKey={props.publicApiKey} showUsageBanner={enabled}>\n        <CopilotKitInternal {...props}>{children}</CopilotKitInternal>\n      </CopilotErrorBoundary>\n    </ToastProvider>\n  );\n}\n\nexport function CopilotKitInternal(cpkProps: CopilotKitProps) {\n  const { children, ...props } = cpkProps;\n\n  /**\n   * This will throw an error if the props are invalid.\n   */\n  validateProps(cpkProps);\n\n  const chatApiEndpoint = props.runtimeUrl || COPILOT_CLOUD_CHAT_URL;\n\n  const [actions, setActions] = useState<Record<string, FrontendAction<any>>>({});\n  const [coAgentStateRenders, setCoAgentStateRenders] = useState<\n    Record<string, CoAgentStateRender<any>>\n  >({});\n\n  const chatComponentsCache = useRef<ChatComponentsCache>({\n    actions: {},\n    coAgentStateRenders: {},\n  });\n\n  const { addElement, removeElement, printTree } = useTree();\n  const [isLoading, setIsLoading] = useState(false);\n  const [chatInstructions, setChatInstructions] = useState(\"\");\n  const [authStates, setAuthStates] = useState<Record<string, AuthState>>({});\n  const [extensions, setExtensions] = useState<ExtensionsInput>({});\n  const [additionalInstructions, setAdditionalInstructions] = useState<string[]>([]);\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  // Compute all the functions and properties that we need to pass\n\n  const setAction = useCallback((id: string, action: FrontendAction<any>) => {\n    setActions((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: action,\n      };\n    });\n  }, []);\n\n  const removeAction = useCallback((id: string) => {\n    setActions((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const setCoAgentStateRender = useCallback((id: string, stateRender: CoAgentStateRender<any>) => {\n    setCoAgentStateRenders((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: stateRender,\n      };\n    });\n  }, []);\n\n  const removeCoAgentStateRender = useCallback((id: string) => {\n    setCoAgentStateRenders((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, FrontendAction<any>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));\n    },\n    [actions],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = useMemo(() => {\n    let cloud: CopilotCloudConfig | undefined = undefined;\n    if (props.publicApiKey) {\n      cloud = {\n        guardrails: {\n          input: {\n            restrictToTopic: {\n              enabled: Boolean(props.guardrails_c),\n              validTopics: props.guardrails_c?.validTopics || [],\n              invalidTopics: props.guardrails_c?.invalidTopics || [],\n            },\n          },\n        },\n      };\n    }\n\n    return {\n      publicApiKey: props.publicApiKey,\n      ...(cloud ? { cloud } : {}),\n      chatApiEndpoint: chatApiEndpoint,\n      headers: props.headers || {},\n      properties: props.properties || {},\n      transcribeAudioUrl: props.transcribeAudioUrl,\n      textToSpeechUrl: props.textToSpeechUrl,\n      credentials: props.credentials,\n    };\n  }, [\n    props.publicApiKey,\n    props.headers,\n    props.properties,\n    props.transcribeAudioUrl,\n    props.textToSpeechUrl,\n    props.credentials,\n    props.cloudRestrictToTopic,\n  ]);\n\n  const headers = useMemo(() => {\n    const authHeaders = Object.values(authStates || {}).reduce((acc, state) => {\n      if (state.status === \"authenticated\" && state.authHeaders) {\n        return {\n          ...acc,\n          ...Object.entries(state.authHeaders).reduce(\n            (headers, [key, value]) => ({\n              ...headers,\n              [key.startsWith(\"X-Custom-\") ? key : `X-Custom-${key}`]: value,\n            }),\n            {},\n          ),\n        };\n      }\n      return acc;\n    }, {});\n\n    return {\n      ...(copilotApiConfig.headers || {}),\n      ...(copilotApiConfig.publicApiKey\n        ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey }\n        : {}),\n      ...authHeaders,\n    };\n  }, [copilotApiConfig.headers, copilotApiConfig.publicApiKey, authStates]);\n\n  const runtimeClient = useCopilotRuntimeClient({\n    url: copilotApiConfig.chatApiEndpoint,\n    publicApiKey: copilotApiConfig.publicApiKey,\n    headers,\n    credentials: copilotApiConfig.credentials,\n  });\n\n  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = useState<{\n    [key: string]: CopilotChatSuggestionConfiguration;\n  }>({});\n\n  const addChatSuggestionConfiguration = (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => {\n    setChatSuggestionConfiguration((prev) => ({ ...prev, [id]: suggestion }));\n  };\n\n  const removeChatSuggestionConfiguration = (id: string) => {\n    setChatSuggestionConfiguration((prev) => {\n      const { [id]: _, ...rest } = prev;\n      return rest;\n    });\n  };\n\n  const [availableAgents, setAvailableAgents] = useState<Agent[]>([]);\n  const [coagentStates, setCoagentStates] = useState<Record<string, CoagentState>>({});\n  const coagentStatesRef = useRef<Record<string, CoagentState>>({});\n  const setCoagentStatesWithRef = useCallback(\n    (\n      value:\n        | Record<string, CoagentState>\n        | ((prev: Record<string, CoagentState>) => Record<string, CoagentState>),\n    ) => {\n      const newValue = typeof value === \"function\" ? value(coagentStatesRef.current) : value;\n      coagentStatesRef.current = newValue;\n      setCoagentStates((prev) => {\n        return newValue;\n      });\n    },\n    [],\n  );\n  const hasLoadedAgents = useRef(false);\n\n  useEffect(() => {\n    if (hasLoadedAgents.current) return;\n\n    const fetchData = async () => {\n      const result = await runtimeClient.availableAgents();\n      if (result.data?.availableAgents) {\n        setAvailableAgents(result.data.availableAgents.agents);\n      }\n      hasLoadedAgents.current = true;\n    };\n    void fetchData();\n  }, []);\n\n  let initialAgentSession: AgentSession | null = null;\n  if (props.agent) {\n    initialAgentSession = {\n      agentName: props.agent,\n    };\n  }\n\n  const [agentSession, setAgentSession] = useState<AgentSession | null>(initialAgentSession);\n\n  // Update agentSession when props.agent changes\n  useEffect(() => {\n    if (props.agent) {\n      setAgentSession({\n        agentName: props.agent,\n      });\n    } else {\n      setAgentSession(null);\n    }\n  }, [props.agent]);\n\n  const [internalThreadId, setInternalThreadId] = useState<string>(props.threadId || randomUUID());\n  const setThreadId = useCallback(\n    (value: SetStateAction<string>) => {\n      if (props.threadId) {\n        throw new Error(\"Cannot call setThreadId() when threadId is provided via props.\");\n      }\n      setInternalThreadId(value);\n    },\n    [props.threadId],\n  );\n\n  // update the internal threadId if the props.threadId changes\n  useEffect(() => {\n    if (props.threadId !== undefined) {\n      setInternalThreadId(props.threadId);\n    }\n  }, [props.threadId]);\n\n  const [runId, setRunId] = useState<string | null>(null);\n\n  const chatAbortControllerRef = useRef<AbortController | null>(null);\n\n  const showDevConsole = props.showDevConsole === undefined ? \"auto\" : props.showDevConsole;\n\n  const [langGraphInterruptAction, _setLangGraphInterruptAction] =\n    useState<LangGraphInterruptAction | null>(null);\n  const setLangGraphInterruptAction = useCallback((action: LangGraphInterruptActionSetterArgs) => {\n    _setLangGraphInterruptAction((prev) => {\n      if (prev == null) return action as LangGraphInterruptAction;\n      if (action == null) return null;\n      let event = prev.event;\n      if (action.event) {\n        // @ts-ignore\n        event = { ...prev.event, ...action.event };\n      }\n      return { ...prev, ...action, event };\n    });\n  }, []);\n  const removeLangGraphInterruptAction = useCallback((): void => {\n    setLangGraphInterruptAction(null);\n  }, []);\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        actions,\n        chatComponentsCache,\n        getFunctionCallHandler,\n        setAction,\n        removeAction,\n        coAgentStateRenders,\n        setCoAgentStateRender,\n        removeCoAgentStateRender,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n        isLoading,\n        setIsLoading,\n        chatSuggestionConfiguration,\n        addChatSuggestionConfiguration,\n        removeChatSuggestionConfiguration,\n        chatInstructions,\n        setChatInstructions,\n        additionalInstructions,\n        setAdditionalInstructions,\n        showDevConsole,\n        coagentStates,\n        setCoagentStates,\n        coagentStatesRef,\n        setCoagentStatesWithRef,\n        agentSession,\n        setAgentSession,\n        runtimeClient,\n        forwardedParameters: props.forwardedParameters || {},\n        agentLock: props.agent || null,\n        threadId: internalThreadId,\n        setThreadId,\n        runId,\n        setRunId,\n        chatAbortControllerRef,\n        availableAgents,\n        authConfig_c: props.authConfig_c,\n        authStates_c: authStates,\n        setAuthStates_c: setAuthStates,\n        extensions,\n        setExtensions,\n        langGraphInterruptAction,\n        setLangGraphInterruptAction,\n        removeLangGraphInterruptAction,\n      }}\n    >\n      <CopilotMessages>{children}</CopilotMessages>\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(actions: FrontendAction<any>[]): FunctionCallHandler {\n  return async ({ name, args }) => {\n    let actionsByFunctionName: Record<string, FrontendAction<any>> = {};\n    for (let action of actions) {\n      actionsByFunctionName[action.name] = action;\n    }\n\n    const action = actionsByFunctionName[name];\n    let result: any = undefined;\n    if (action) {\n      await new Promise<void>((resolve, reject) => {\n        flushSync(async () => {\n          try {\n            result = await action.handler?.(args);\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n      await new Promise((resolve) => setTimeout(resolve, 20));\n    }\n    return result;\n  };\n}\n\nfunction formatFeatureName(featureName: string): string {\n  return featureName\n    .replace(/_c$/, \"\")\n    .split(\"_\")\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(\" \");\n}\n\nfunction validateProps(props: CopilotKitProps): never | void {\n  const cloudFeatures = Object.keys(props).filter((key) => key.endsWith(\"_c\"));\n\n  if (!props.runtimeUrl && !props.publicApiKey) {\n    throw new ConfigurationError(\"Missing required prop: 'runtimeUrl' or 'publicApiKey'\");\n  }\n\n  if (cloudFeatures.length > 0 && !props.publicApiKey) {\n    throw new MissingPublicApiKeyError(\n      `Missing required prop: 'publicApiKey' to use cloud features: ${cloudFeatures\n        .map(formatFeatureName)\n        .join(\", \")}`,\n    );\n  }\n}\n"],"names":["_a","headers","action"],"mappings":"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","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 1935, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1941, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/types/frontend-action.ts"],"sourcesContent":["import { ActionInputAvailability } from \"@copilotkit/runtime-client-gql\";\nimport {\n  Action,\n  Parameter,\n  MappedParameterTypes,\n  actionParametersToJsonSchema,\n} from \"@copilotkit/shared\";\nimport React from \"react\";\n\ninterface InProgressState<T extends Parameter[] | [] = []> {\n  status: \"inProgress\";\n  args: Partial<MappedParameterTypes<T>>;\n  result: undefined;\n}\n\ninterface ExecutingState<T extends Parameter[] | [] = []> {\n  status: \"executing\";\n  args: MappedParameterTypes<T>;\n  result: undefined;\n}\n\ninterface CompleteState<T extends Parameter[] | [] = []> {\n  status: \"complete\";\n  args: MappedParameterTypes<T>;\n  result: any;\n}\n\ninterface InProgressStateNoArgs<T extends Parameter[] | [] = []> {\n  status: \"inProgress\";\n  args: Partial<MappedParameterTypes<T>>;\n  result: undefined;\n}\n\ninterface ExecutingStateNoArgs<T extends Parameter[] | [] = []> {\n  status: \"executing\";\n  args: MappedParameterTypes<T>;\n  result: undefined;\n}\n\ninterface CompleteStateNoArgs<T extends Parameter[] | [] = []> {\n  status: \"complete\";\n  args: MappedParameterTypes<T>;\n  result: any;\n}\n\ninterface InProgressStateWait<T extends Parameter[] | [] = []> {\n  status: \"inProgress\";\n  args: Partial<MappedParameterTypes<T>>;\n  /** @deprecated use respond instead */\n  handler: undefined;\n  respond: undefined;\n  result: undefined;\n}\n\ninterface ExecutingStateWait<T extends Parameter[] | [] = []> {\n  status: \"executing\";\n  args: MappedParameterTypes<T>;\n  /** @deprecated use respond instead */\n  handler: (result: any) => void;\n  respond: (result: any) => void;\n  result: undefined;\n}\n\ninterface CompleteStateWait<T extends Parameter[] | [] = []> {\n  status: \"complete\";\n  args: MappedParameterTypes<T>;\n  /** @deprecated use respond instead */\n  handler: undefined;\n  respond: undefined;\n  result: any;\n}\n\ninterface InProgressStateNoArgsWait<T extends Parameter[] | [] = []> {\n  status: \"inProgress\";\n  args: Partial<MappedParameterTypes<T>>;\n  /** @deprecated use respond instead */\n  handler: undefined;\n  respond: undefined;\n  result: undefined;\n}\n\ninterface ExecutingStateNoArgsWait<T extends Parameter[] | [] = []> {\n  status: \"executing\";\n  args: MappedParameterTypes<T>;\n  /** @deprecated use respond instead */\n  handler: (result: any) => void;\n  respond: (result: any) => void;\n  result: undefined;\n}\n\ninterface CompleteStateNoArgsWait<T extends Parameter[] | [] = []> {\n  status: \"complete\";\n  args: MappedParameterTypes<T>;\n  /** @deprecated use respond instead */\n  handler: undefined;\n  respond: undefined;\n}\n\nexport type ActionRenderProps<T extends Parameter[] | [] = []> =\n  | CompleteState<T>\n  | ExecutingState<T>\n  | InProgressState<T>;\n\nexport type ActionRenderPropsNoArgs<T extends Parameter[] | [] = []> =\n  | CompleteStateNoArgs<T>\n  | ExecutingStateNoArgs<T>\n  | InProgressStateNoArgs<T>;\n\nexport type ActionRenderPropsWait<T extends Parameter[] | [] = []> =\n  | CompleteStateWait<T>\n  | ExecutingStateWait<T>\n  | InProgressStateWait<T>;\n\nexport type ActionRenderPropsNoArgsWait<T extends Parameter[] | [] = []> =\n  | CompleteStateNoArgsWait<T>\n  | ExecutingStateNoArgsWait<T>\n  | InProgressStateNoArgsWait<T>;\n\nexport type CatchAllActionRenderProps<T extends Parameter[] | [] = []> =\n  | (CompleteState<T> & {\n      name: string;\n    })\n  | (ExecutingState<T> & {\n      name: string;\n    })\n  | (InProgressState<T> & {\n      name: string;\n    });\n\nexport type FrontendActionAvailability = \"disabled\" | \"enabled\" | \"remote\" | \"frontend\";\n\nexport type FrontendAction<\n  T extends Parameter[] | [] = [],\n  N extends string = string,\n> = Action<T> & {\n  name: Exclude<N, \"*\">;\n  /**\n   * @deprecated Use `available` instead.\n   */\n  disabled?: boolean;\n  available?: FrontendActionAvailability;\n  pairedAction?: string;\n  followUp?: boolean;\n} & (\n    | {\n        render?:\n          | string\n          | (T extends []\n              ? (props: ActionRenderPropsNoArgs<T>) => string | React.ReactElement\n              : (props: ActionRenderProps<T>) => string | React.ReactElement);\n        /** @deprecated use renderAndWaitForResponse instead */\n        renderAndWait?: never;\n        renderAndWaitForResponse?: never;\n      }\n    | {\n        render?: never;\n        /** @deprecated use renderAndWaitForResponse instead */\n        renderAndWait?: T extends []\n          ? (props: ActionRenderPropsNoArgsWait<T>) => React.ReactElement\n          : (props: ActionRenderPropsWait<T>) => React.ReactElement;\n        renderAndWaitForResponse?: T extends []\n          ? (props: ActionRenderPropsNoArgsWait<T>) => React.ReactElement\n          : (props: ActionRenderPropsWait<T>) => React.ReactElement;\n        handler?: never;\n      }\n  );\n\nexport type CatchAllFrontendAction = {\n  name: \"*\";\n  render: (props: CatchAllActionRenderProps<any>) => React.ReactElement;\n};\n\nexport type RenderFunctionStatus = ActionRenderProps<any>[\"status\"];\n\nexport function processActionsForRuntimeRequest(actions: FrontendAction<any>[]) {\n  const filteredActions = actions\n    .filter(\n      (action) =>\n        action.available !== ActionInputAvailability.Disabled &&\n        action.disabled !== true &&\n        action.name !== \"*\" &&\n        action.available != \"frontend\" &&\n        !action.pairedAction,\n    )\n    .map((action) => {\n      let available: ActionInputAvailability | undefined = ActionInputAvailability.Enabled;\n      if (action.disabled) {\n        available = ActionInputAvailability.Disabled;\n      } else if (action.available === \"disabled\") {\n        available = ActionInputAvailability.Disabled;\n      } else if (action.available === \"remote\") {\n        available = ActionInputAvailability.Remote;\n      }\n      return {\n        name: action.name,\n        description: action.description || \"\",\n        jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n        available,\n      };\n    });\n  return filteredActions;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,+BAA+B;AACxC;;;AA6KO,SAAS,gCAAgC,OAAA,EAAgC;IAC9E,MAAM,kBAAkB,QACrB,MAAA,CACC,CAAC,SACC,OAAO,SAAA,+LAAc,0BAAA,CAAwB,QAAA,IAC7C,OAAO,QAAA,KAAa,QACpB,OAAO,IAAA,KAAS,OAChB,OAAO,SAAA,IAAa,cACpB,CAAC,OAAO,YAAA,EAEX,GAAA,CAAI,CAAC,WAAW;QACf,IAAI,sMAAiD,0BAAA,CAAwB,OAAA;QAC7E,IAAI,OAAO,QAAA,EAAU;YACnB,sMAAY,0BAAA,CAAwB,QAAA;QACtC,OAAA,IAAW,OAAO,SAAA,KAAc,YAAY;YAC1C,qMAAY,2BAAA,CAAwB,QAAA;QACtC,OAAA,IAAW,OAAO,SAAA,KAAc,UAAU;YACxC,sMAAY,0BAAA,CAAwB,MAAA;QACtC;QACA,OAAO;YACL,MAAM,OAAO,IAAA;YACb,aAAa,OAAO,WAAA,IAAe;YACnC,YAAY,KAAK,SAAA,6KAAU,+BAAA,EAA6B,OAAO,UAAA,IAAc,CAAC,CAAC,CAAC;YAChF;QACF;IACF,CAAC;IACH,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1970, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1976, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/lib/copilot-task.ts"],"sourcesContent":["/**\n * This class is used to execute one-off tasks, for example on button press. It can use the context available via [useCopilotReadable](/reference/hooks/useCopilotReadable) and the actions provided by [useCopilotAction](/reference/hooks/useCopilotAction), or you can provide your own context and actions.\n *\n * ## Example\n * In the simplest case, use CopilotTask in the context of your app by giving it instructions on what to do.\n *\n * ```tsx\n * import { CopilotTask, useCopilotContext } from \"@copilotkit/react-core\";\n *\n * export function MyComponent() {\n *   const context = useCopilotContext();\n *\n *   const task = new CopilotTask({\n *     instructions: \"Set a random message\",\n *     actions: [\n *       {\n *         name: \"setMessage\",\n *       description: \"Set the message.\",\n *       argumentAnnotations: [\n *         {\n *           name: \"message\",\n *           type: \"string\",\n *           description:\n *             \"A message to display.\",\n *           required: true,\n *         },\n *       ],\n *      }\n *     ]\n *   });\n *\n *   const executeTask = async () => {\n *     await task.run(context, action);\n *   }\n *\n *   return (\n *     <>\n *       <button onClick={executeTask}>\n *         Execute task\n *       </button>\n *     </>\n *   )\n * }\n * ```\n *\n * Have a look at the [Presentation Example App](https://github.com/CopilotKit/CopilotKit/blob/main/CopilotKit/examples/next-openai/src/app/presentation/page.tsx) for a more complete example.\n */\n\nimport {\n  ActionExecutionMessage,\n  CopilotRuntimeClient,\n  Message,\n  Role,\n  TextMessage,\n  convertGqlOutputToMessages,\n  convertMessagesToGqlInput,\n  filterAgentStateMessages,\n  CopilotRequestType,\n  ForwardedParametersInput,\n} from \"@copilotkit/runtime-client-gql\";\nimport { FrontendAction, processActionsForRuntimeRequest } from \"../types/frontend-action\";\nimport { CopilotContextParams } from \"../context\";\nimport { defaultCopilotContextCategories } from \"../components\";\n\nexport interface CopilotTaskConfig {\n  /**\n   * The instructions to be given to the assistant.\n   */\n  instructions: string;\n  /**\n   * An array of action definitions that can be called.\n   */\n  actions?: FrontendAction<any>[];\n  /**\n   * Whether to include the copilot readable context in the task.\n   */\n  includeCopilotReadable?: boolean;\n\n  /**\n   * Whether to include actions defined via useCopilotAction in the task.\n   */\n  includeCopilotActions?: boolean;\n\n  /**\n   * The forwarded parameters to use for the task.\n   */\n  forwardedParameters?: ForwardedParametersInput;\n}\n\nexport class CopilotTask<T = any> {\n  private instructions: string;\n  private actions: FrontendAction<any>[];\n  private includeCopilotReadable: boolean;\n  private includeCopilotActions: boolean;\n  private forwardedParameters?: ForwardedParametersInput;\n  constructor(config: CopilotTaskConfig) {\n    this.instructions = config.instructions;\n    this.actions = config.actions || [];\n    this.includeCopilotReadable = config.includeCopilotReadable !== false;\n    this.includeCopilotActions = config.includeCopilotActions !== false;\n    this.forwardedParameters = config.forwardedParameters;\n  }\n\n  /**\n   * Run the task.\n   * @param context The CopilotContext to use for the task. Use `useCopilotContext` to obtain the current context.\n   * @param data The data to use for the task.\n   */\n  async run(context: CopilotContextParams, data?: T): Promise<void> {\n    const actions = this.includeCopilotActions ? Object.assign({}, context.actions) : {};\n\n    // merge functions into entry points\n    for (const fn of this.actions) {\n      actions[fn.name] = fn;\n    }\n\n    let contextString = \"\";\n\n    if (data) {\n      contextString = (typeof data === \"string\" ? data : JSON.stringify(data)) + \"\\n\\n\";\n    }\n\n    if (this.includeCopilotReadable) {\n      contextString += context.getContextString([], defaultCopilotContextCategories);\n    }\n\n    const systemMessage = new TextMessage({\n      content: taskSystemMessage(contextString, this.instructions),\n      role: Role.System,\n    });\n\n    const messages: Message[] = [systemMessage];\n\n    const runtimeClient = new CopilotRuntimeClient({\n      url: context.copilotApiConfig.chatApiEndpoint,\n      publicApiKey: context.copilotApiConfig.publicApiKey,\n      headers: context.copilotApiConfig.headers,\n      credentials: context.copilotApiConfig.credentials,\n    });\n\n    const response = await runtimeClient\n      .generateCopilotResponse({\n        data: {\n          frontend: {\n            actions: processActionsForRuntimeRequest(Object.values(actions)),\n            url: window.location.href,\n          },\n          messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),\n          metadata: {\n            requestType: CopilotRequestType.Task,\n          },\n          forwardedParameters: {\n            // if forwardedParameters is provided, use it\n            ...(this.forwardedParameters ?? {}),\n            toolChoice: \"required\",\n          },\n        },\n        properties: context.copilotApiConfig.properties,\n      })\n      .toPromise();\n\n    const functionCallHandler = context.getFunctionCallHandler(actions);\n    const functionCalls = convertGqlOutputToMessages(\n      response.data?.generateCopilotResponse?.messages || [],\n    ).filter((m): m is ActionExecutionMessage => m.isActionExecutionMessage());\n\n    for (const functionCall of functionCalls) {\n      await functionCallHandler({\n        messages,\n        name: functionCall.name,\n        args: functionCall.arguments,\n      });\n    }\n  }\n}\n\nfunction taskSystemMessage(contextString: string, instructions: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf.\n\nPlease assist them as best you can.\n\nThis is not a conversation, so please do not ask questions. Just call a function without saying anything else.\n\nThe user has given you the following task to complete:\n\n\\`\\`\\`\n${instructions}\n\\`\\`\\`\n`;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2085, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2091, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-langgraph-interrupt-render.ts"],"sourcesContent":["import { useCopilotContext } from \"../context\";\nimport React, { useCallback } from \"react\";\nimport { executeConditions } from \"@copilotkit/shared\";\n\ntype InterruptProps = {\n  event: any;\n  result: any;\n  render: (props: {\n    event: any;\n    result: any;\n    resolve: (response: string) => void;\n  }) => string | React.ReactElement;\n  resolve: (response: string) => void;\n};\n\nconst InterruptRenderer: React.FC<InterruptProps> = ({ event, result, render, resolve }) => {\n  return render({ event, result, resolve });\n};\n\nexport function useLangGraphInterruptRender(): string | React.ReactElement | null {\n  const { langGraphInterruptAction, setLangGraphInterruptAction, agentSession } =\n    useCopilotContext();\n\n  const responseRef = React.useRef<string>();\n  const resolveInterrupt = useCallback(\n    (response: string) => {\n      responseRef.current = response;\n      // Use setTimeout to defer the state update to next tick\n      setTimeout(() => {\n        setLangGraphInterruptAction({ event: { response } });\n      }, 0);\n    },\n    [setLangGraphInterruptAction],\n  );\n\n  if (\n    !langGraphInterruptAction ||\n    !langGraphInterruptAction.event ||\n    !langGraphInterruptAction.render\n  )\n    return null;\n\n  const { render, handler, event, enabled } = langGraphInterruptAction;\n\n  const conditionsMet =\n    !agentSession || !enabled\n      ? true\n      : enabled({ eventValue: event.value, agentMetadata: agentSession });\n  if (!conditionsMet) {\n    return null;\n  }\n\n  let result = null;\n  if (handler) {\n    result = handler({\n      event,\n      resolve: resolveInterrupt,\n    });\n  }\n\n  return React.createElement(InterruptRenderer, {\n    event,\n    result,\n    render,\n    resolve: resolveInterrupt,\n  });\n}\n"],"names":[],"mappings":";;;;;AACA,OAAO,SAAS,mBAAmB;;;AAcnC,IAAM,oBAA8C,CAAC,EAAE,KAAA,EAAO,MAAA,EAAQ,MAAA,EAAQ,OAAA,CAAQ,CAAA,KAAM;IAC1F,OAAO,OAAO;QAAE;QAAO;QAAQ;IAAQ,CAAC;AAC1C;AAEO,SAAS,8BAAkE;IAChF,MAAM,EAAE,wBAAA,EAA0B,2BAAA,EAA6B,YAAA,CAAa,CAAA,sLAC1E,oBAAA,CAAkB;IAEpB,MAAM,4KAAc,UAAA,CAAM,MAAA,CAAe;IACzC,MAAM,qLAAmB,cAAA;qEACvB,CAAC,aAAqB;YACpB,YAAY,OAAA,GAAU;YAEtB;6EAAW,MAAM;oBACf,4BAA4B;wBAAE,OAAO;4BAAE;wBAAS;oBAAE,CAAC;gBACrD;4EAAG,CAAC;QACN;oEACA;QAAC,2BAA2B;KAAA;IAG9B,IACE,CAAC,4BACD,CAAC,yBAAyB,KAAA,IAC1B,CAAC,yBAAyB,MAAA,EAE1B,OAAO;IAET,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,KAAA,EAAO,OAAA,CAAQ,CAAA,GAAI;IAE5C,MAAM,gBACJ,CAAC,gBAAgB,CAAC,UACd,OACA,QAAQ;QAAE,YAAY,MAAM,KAAA;QAAO,eAAe;IAAa,CAAC;IACtE,IAAI,CAAC,eAAe;QAClB,OAAO;IACT;IAEA,IAAI,SAAS;IACb,IAAI,SAAS;QACX,SAAS,QAAQ;YACf;YACA,SAAS;QACX,CAAC;IACH;IAEA,qKAAO,UAAA,CAAM,aAAA,CAAc,mBAAmB;QAC5C;QACA;QACA;QACA,SAAS;IACX,CAAC;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2150, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2156, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-chat.ts"],"sourcesContent":["import React, { useCallback, useRef } from \"react\";\nimport {\n  FunctionCallHandler,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  CoAgentStateRenderHandler,\n  randomId,\n  parseJson,\n} from \"@copilotkit/shared\";\nimport {\n  Message,\n  TextMessage,\n  ResultMessage,\n  convertMessagesToGqlInput,\n  filterAdjacentAgentStateMessages,\n  filterAgentStateMessages,\n  convertGqlOutputToMessages,\n  MessageStatusCode,\n  MessageRole,\n  Role,\n  CopilotRequestType,\n  ForwardedParametersInput,\n  loadMessagesFromJsonRepresentation,\n  ExtensionsInput,\n  CopilotRuntimeClient,\n  langGraphInterruptEvent,\n  MetaEvent,\n  MetaEventName,\n  ActionExecutionMessage,\n  CopilotKitLangGraphInterruptEvent,\n  LangGraphInterruptEvent,\n  MetaEventInput,\n} from \"@copilotkit/runtime-client-gql\";\n\nimport { CopilotApiConfig } from \"../context\";\nimport { FrontendAction, processActionsForRuntimeRequest } from \"../types/frontend-action\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport { AgentSession } from \"../context/copilot-context\";\nimport { useCopilotRuntimeClient } from \"./use-copilot-runtime-client\";\nimport { useAsyncCallback, useErrorToast } from \"../components/error-boundary/error-utils\";\nimport {\n  LangGraphInterruptAction,\n  LangGraphInterruptActionSetter,\n} from \"../types/interrupt-action\";\n\nexport type UseChatOptions = {\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n\n  /**\n   * Callback function to be called when a coagent action is received.\n   */\n  onCoAgentStateRender?: CoAgentStateRenderHandler;\n\n  /**\n   * Function definitions to be sent to the API.\n   */\n  actions: FrontendAction<any>[];\n\n  /**\n   * The CopilotKit API configuration.\n   */\n  copilotConfig: CopilotApiConfig;\n\n  /**\n   * The current list of messages in the chat.\n   */\n  messages: Message[];\n  /**\n   * The setState-powered method to update the chat messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * A callback to get the latest system message.\n   */\n  makeSystemMessageCallback: () => TextMessage;\n\n  /**\n   * Whether the API request is in progress\n   */\n  isLoading: boolean;\n\n  /**\n   * setState-powered method to update the isChatLoading value\n   */\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  /**\n   * The current list of coagent states.\n   */\n  coagentStatesRef: React.RefObject<Record<string, CoagentState>>;\n\n  /**\n   * setState-powered method to update the agent states\n   */\n  setCoagentStatesWithRef: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n\n  /**\n   * The current agent session.\n   */\n  agentSession: AgentSession | null;\n\n  /**\n   * setState-powered method to update the agent session\n   */\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n\n  /**\n   * The forwarded parameters.\n   */\n  forwardedParameters?: Pick<ForwardedParametersInput, \"temperature\">;\n\n  /**\n   * The current thread ID.\n   */\n  threadId: string;\n  /**\n   * set the current thread ID\n   */\n  setThreadId: (threadId: string) => void;\n  /**\n   * The current run ID.\n   */\n  runId: string | null;\n  /**\n   * set the current run ID\n   */\n  setRunId: (runId: string | null) => void;\n  /**\n   * The global chat abort controller.\n   */\n  chatAbortControllerRef: React.MutableRefObject<AbortController | null>;\n  /**\n   * The agent lock.\n   */\n  agentLock: string | null;\n  /**\n   * The extensions.\n   */\n  extensions: ExtensionsInput;\n  /**\n   * The setState-powered method to update the extensions.\n   */\n  setExtensions: React.Dispatch<React.SetStateAction<ExtensionsInput>>;\n\n  langGraphInterruptAction: LangGraphInterruptAction | null;\n\n  setLangGraphInterruptAction: LangGraphInterruptActionSetter;\n};\n\nexport type UseChatHelpers = {\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message, options?: AppendMessageOptions) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n\n  /**\n   * Run the chat completion.\n   */\n  runChatCompletion: () => Promise<Message[]>;\n};\n\nexport interface AppendMessageOptions {\n  /**\n   * Whether to run the chat completion after appending the message. Defaults to `true`.\n   */\n  followUp?: boolean;\n}\n\nexport function useChat(options: UseChatOptions): UseChatHelpers {\n  const {\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    copilotConfig,\n    setIsLoading,\n    initialMessages,\n    isLoading,\n    actions,\n    onFunctionCall,\n    onCoAgentStateRender,\n    setCoagentStatesWithRef,\n    coagentStatesRef,\n    agentSession,\n    setAgentSession,\n    threadId,\n    setThreadId,\n    runId,\n    setRunId,\n    chatAbortControllerRef,\n    agentLock,\n    extensions,\n    setExtensions,\n    langGraphInterruptAction,\n    setLangGraphInterruptAction,\n  } = options;\n  const runChatCompletionRef = useRef<(previousMessages: Message[]) => Promise<Message[]>>();\n  const addErrorToast = useErrorToast();\n  // We need to keep a ref of coagent states and session because of renderAndWait - making sure\n  // the latest state is sent to the API\n  // This is a workaround and needs to be addressed in the future\n  const agentSessionRef = useRef<AgentSession | null>(agentSession);\n  agentSessionRef.current = agentSession;\n\n  const runIdRef = useRef<string | null>(runId);\n  runIdRef.current = runId;\n  const extensionsRef = useRef<ExtensionsInput>(extensions);\n  extensionsRef.current = extensions;\n\n  const publicApiKey = copilotConfig.publicApiKey;\n\n  const headers = {\n    ...(copilotConfig.headers || {}),\n    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),\n  };\n\n  const runtimeClient = useCopilotRuntimeClient({\n    url: copilotConfig.chatApiEndpoint,\n    publicApiKey: copilotConfig.publicApiKey,\n    headers,\n    credentials: copilotConfig.credentials,\n  });\n\n  const runChatCompletion = useAsyncCallback(\n    async (previousMessages: Message[]): Promise<Message[]> => {\n      setIsLoading(true);\n      const interruptEvent = langGraphInterruptAction?.event;\n      // In case an interrupt event exist and valid but has no response yet, we cannot process further messages to an agent\n      if (\n        interruptEvent?.name === MetaEventName.LangGraphInterruptEvent &&\n        interruptEvent?.value &&\n        !interruptEvent?.response &&\n        agentSessionRef.current\n      ) {\n        addErrorToast([\n          new Error(\n            \"A message was sent while interrupt is active. This will cause failure on the agent side\",\n          ),\n        ]);\n      }\n\n      // this message is just a placeholder. It will disappear once the first real message\n      // is received\n      let newMessages: Message[] = [\n        new TextMessage({\n          content: \"\",\n          role: Role.Assistant,\n        }),\n      ];\n\n      chatAbortControllerRef.current = new AbortController();\n\n      setMessages([...previousMessages, ...newMessages]);\n\n      const systemMessage = makeSystemMessageCallback();\n\n      const messagesWithContext = [systemMessage, ...(initialMessages || []), ...previousMessages];\n\n      const isAgentRun = agentSessionRef.current !== null;\n\n      const stream = runtimeClient.asStream(\n        runtimeClient.generateCopilotResponse({\n          data: {\n            frontend: {\n              actions: processActionsForRuntimeRequest(actions),\n              url: window.location.href,\n            },\n            threadId: threadId,\n            runId: runIdRef.current,\n            extensions: extensionsRef.current,\n            metaEvents: composeAndFlushMetaEventsInput([langGraphInterruptAction?.event]),\n            messages: convertMessagesToGqlInput(filterAgentStateMessages(messagesWithContext)),\n            ...(copilotConfig.cloud\n              ? {\n                  cloud: {\n                    ...(copilotConfig.cloud.guardrails?.input?.restrictToTopic?.enabled\n                      ? {\n                          guardrails: {\n                            inputValidationRules: {\n                              allowList:\n                                copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,\n                              denyList:\n                                copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics,\n                            },\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n            metadata: {\n              requestType: CopilotRequestType.Chat,\n            },\n            ...(agentSessionRef.current\n              ? {\n                  agentSession: agentSessionRef.current,\n                }\n              : {}),\n            agentStates: Object.values(coagentStatesRef.current!).map((state) => ({\n              agentName: state.name,\n              state: JSON.stringify(state.state),\n              configurable: JSON.stringify(state.configurable ?? {}),\n            })),\n            forwardedParameters: options.forwardedParameters || {},\n          },\n          properties: copilotConfig.properties,\n          signal: chatAbortControllerRef.current?.signal,\n        }),\n      );\n\n      const guardrailsEnabled =\n        copilotConfig.cloud?.guardrails?.input?.restrictToTopic.enabled || false;\n\n      const reader = stream.getReader();\n\n      let executedCoAgentStateRenders: string[] = [];\n      let followUp: FrontendAction[\"followUp\"] = undefined;\n\n      let messages: Message[] = [];\n      let syncedMessages: Message[] = [];\n      let interruptMessages: Message[] = [];\n\n      try {\n        while (true) {\n          let done, value;\n\n          try {\n            const readResult = await reader.read();\n            done = readResult.done;\n            value = readResult.value;\n          } catch (readError) {\n            break;\n          }\n\n          if (done) {\n            if (chatAbortControllerRef.current.signal.aborted) {\n              return [];\n            }\n            break;\n          }\n\n          if (!value?.generateCopilotResponse) {\n            continue;\n          }\n\n          runIdRef.current = value.generateCopilotResponse.runId || null;\n\n          // in the output, graphql inserts __typename, which leads to an error when sending it along\n          // as input to the next request.\n          extensionsRef.current = CopilotRuntimeClient.removeGraphQLTypename(\n            value.generateCopilotResponse.extensions || {},\n          );\n\n          // setThreadId(threadIdRef.current);\n          setRunId(runIdRef.current);\n          setExtensions(extensionsRef.current);\n          let rawMessagesResponse = value.generateCopilotResponse.messages;\n          (value.generateCopilotResponse?.metaEvents ?? []).forEach((ev) => {\n            if (ev.name === MetaEventName.LangGraphInterruptEvent) {\n              let eventValue = langGraphInterruptEvent(ev as LangGraphInterruptEvent).value;\n              eventValue = parseJson(eventValue, eventValue);\n              setLangGraphInterruptAction({\n                event: {\n                  ...langGraphInterruptEvent(ev as LangGraphInterruptEvent),\n                  value: eventValue,\n                },\n              });\n            }\n            if (ev.name === MetaEventName.CopilotKitLangGraphInterruptEvent) {\n              const data = (ev as CopilotKitLangGraphInterruptEvent).data;\n\n              // @ts-expect-error -- same type of messages\n              rawMessagesResponse = [...rawMessagesResponse, ...data.messages];\n              interruptMessages = convertGqlOutputToMessages(\n                // @ts-ignore\n                filterAdjacentAgentStateMessages(data.messages),\n              );\n            }\n          });\n\n          messages = convertGqlOutputToMessages(\n            filterAdjacentAgentStateMessages(rawMessagesResponse),\n          );\n\n          if (messages.length === 0) {\n            continue;\n          }\n\n          newMessages = [];\n\n          // request failed, display error message and quit\n          if (\n            value.generateCopilotResponse.status?.__typename === \"FailedResponseStatus\" &&\n            value.generateCopilotResponse.status.reason === \"GUARDRAILS_VALIDATION_FAILED\"\n          ) {\n            newMessages = [\n              new TextMessage({\n                role: MessageRole.Assistant,\n                content: value.generateCopilotResponse.status.details?.guardrailsReason || \"\",\n              }),\n            ];\n            setMessages([...previousMessages, ...newMessages]);\n            break;\n          }\n\n          // add messages to the chat\n          else {\n            newMessages = [...messages];\n\n            for (const message of messages) {\n              // execute onCoAgentStateRender handler\n              if (\n                message.isAgentStateMessage() &&\n                !message.active &&\n                !executedCoAgentStateRenders.includes(message.id) &&\n                onCoAgentStateRender\n              ) {\n                // Do not execute a coagent action if guardrails are enabled but the status is not known\n                if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                  break;\n                }\n                // execute coagent action\n                await onCoAgentStateRender({\n                  name: message.agentName,\n                  nodeName: message.nodeName,\n                  state: message.state,\n                });\n                executedCoAgentStateRenders.push(message.id);\n              }\n            }\n\n            const lastAgentStateMessage = [...messages]\n              .reverse()\n              .find((message) => message.isAgentStateMessage());\n\n            if (lastAgentStateMessage) {\n              if (\n                lastAgentStateMessage.state.messages &&\n                lastAgentStateMessage.state.messages.length > 0\n              ) {\n                syncedMessages = loadMessagesFromJsonRepresentation(\n                  lastAgentStateMessage.state.messages,\n                );\n              }\n              setCoagentStatesWithRef((prevAgentStates) => ({\n                ...prevAgentStates,\n                [lastAgentStateMessage.agentName]: {\n                  name: lastAgentStateMessage.agentName,\n                  state: lastAgentStateMessage.state,\n                  running: lastAgentStateMessage.running,\n                  active: lastAgentStateMessage.active,\n                  threadId: lastAgentStateMessage.threadId,\n                  nodeName: lastAgentStateMessage.nodeName,\n                  runId: lastAgentStateMessage.runId,\n                },\n              }));\n              if (lastAgentStateMessage.running) {\n                setAgentSession({\n                  threadId: lastAgentStateMessage.threadId,\n                  agentName: lastAgentStateMessage.agentName,\n                  nodeName: lastAgentStateMessage.nodeName,\n                });\n              } else {\n                if (agentLock) {\n                  setAgentSession({\n                    threadId: randomId(),\n                    agentName: agentLock,\n                    nodeName: undefined,\n                  });\n                } else {\n                  setAgentSession(null);\n                }\n              }\n            }\n          }\n\n          if (newMessages.length > 0) {\n            // Update message state\n            setMessages([...previousMessages, ...newMessages]);\n          }\n        }\n        let finalMessages = constructFinalMessages(\n          [...syncedMessages, ...interruptMessages],\n          previousMessages,\n          newMessages,\n        );\n\n        let didExecuteAction = false;\n\n        // execute regular action executions that are specific to the frontend (last actions)\n        if (onFunctionCall) {\n          // Find consecutive action execution messages at the end\n          const lastMessages = [];\n          for (let i = finalMessages.length - 1; i >= 0; i--) {\n            const message = finalMessages[i];\n            if (\n              (message.isActionExecutionMessage() || message.isResultMessage()) &&\n              message.status.code !== MessageStatusCode.Pending\n            ) {\n              lastMessages.unshift(message);\n            } else {\n              break;\n            }\n          }\n\n          for (const message of lastMessages) {\n            // We update the message state before calling the handler so that the render\n            // function can be called with `executing` state\n            setMessages(finalMessages);\n\n            const action = actions.find(\n              (action) => action.name === (message as ActionExecutionMessage).name,\n            );\n            const currentResultMessagePairedFeAction = message.isResultMessage()\n              ? getPairedFeAction(actions, message)\n              : null;\n\n            const executeActionFromMessage = async (\n              action: FrontendAction<any>,\n              message: ActionExecutionMessage,\n            ) => {\n              followUp = action?.followUp;\n              const resultMessage = await executeAction({\n                onFunctionCall,\n                previousMessages,\n                message,\n                chatAbortControllerRef,\n                onError: (error: Error) => {\n                  addErrorToast([error]);\n                  console.error(`Failed to execute action ${message.name}: ${error}`);\n                },\n              });\n              didExecuteAction = true;\n              const messageIndex = finalMessages.findIndex((msg) => msg.id === message.id);\n              finalMessages.splice(messageIndex + 1, 0, resultMessage);\n\n              return resultMessage;\n            };\n\n            // execution message which has an action registered with the hook (remote availability):\n            // execute that action first, and then the \"paired FE action\"\n            if (action && message.isActionExecutionMessage()) {\n              const resultMessage = await executeActionFromMessage(action, message);\n              const pairedFeAction = getPairedFeAction(actions, resultMessage);\n\n              if (pairedFeAction) {\n                const newExecutionMessage = new ActionExecutionMessage({\n                  name: pairedFeAction.name,\n                  arguments: parseJson(resultMessage.result, resultMessage.result),\n                  status: message.status,\n                  createdAt: message.createdAt,\n                  parentMessageId: message.parentMessageId,\n                });\n                await executeActionFromMessage(pairedFeAction, newExecutionMessage);\n              }\n            } else if (message.isResultMessage() && currentResultMessagePairedFeAction) {\n              // Actions which are set up in runtime actions array: Grab the result, executed paired FE action with it as args.\n              const newExecutionMessage = new ActionExecutionMessage({\n                name: currentResultMessagePairedFeAction.name,\n                arguments: parseJson(message.result, message.result),\n                status: message.status,\n                createdAt: message.createdAt,\n              });\n              finalMessages.push(newExecutionMessage);\n              await executeActionFromMessage(\n                currentResultMessagePairedFeAction,\n                newExecutionMessage,\n              );\n            }\n          }\n\n          setMessages(finalMessages);\n        }\n\n        if (\n          // if followUp is not explicitly false\n          followUp !== false &&\n          // and we executed an action\n          (didExecuteAction ||\n            // the last message is a server side result\n            (!isAgentRun &&\n              finalMessages.length &&\n              finalMessages[finalMessages.length - 1].isResultMessage())) &&\n          // the user did not stop generation\n          !chatAbortControllerRef.current?.signal.aborted\n        ) {\n          // run the completion again and return the result\n\n          // wait for next tick to make sure all the react state updates\n          // - tried using react-dom's flushSync, but it did not work\n          await new Promise((resolve) => setTimeout(resolve, 10));\n\n          return await runChatCompletionRef.current!(finalMessages);\n        } else if (chatAbortControllerRef.current?.signal.aborted) {\n          // filter out all the action execution messages that do not have a consecutive matching result message\n          const repairedMessages = finalMessages.filter((message, actionExecutionIndex) => {\n            if (message.isActionExecutionMessage()) {\n              return finalMessages.find(\n                (msg, resultIndex) =>\n                  msg.isResultMessage() &&\n                  msg.actionExecutionId === message.id &&\n                  resultIndex === actionExecutionIndex + 1,\n              );\n            }\n            return true;\n          });\n          const repairedMessageIds = repairedMessages.map((message) => message.id);\n          setMessages(repairedMessages);\n\n          // LangGraph needs two pieces of information to continue execution:\n          // 1. The threadId\n          // 2. The nodeName it came from\n          // When stopping the agent, we don't know the nodeName the agent would have ended with\n          // Therefore, we set the nodeName to the most reasonable thing we can guess, which\n          // is \"__end__\"\n          if (agentSessionRef.current?.nodeName) {\n            setAgentSession({\n              threadId: agentSessionRef.current.threadId,\n              agentName: agentSessionRef.current.agentName,\n              nodeName: \"__end__\",\n            });\n          }\n          // only return new messages that were not filtered out\n          return newMessages.filter((message) => repairedMessageIds.includes(message.id));\n        } else {\n          return newMessages.slice();\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [\n      messages,\n      setMessages,\n      makeSystemMessageCallback,\n      copilotConfig,\n      setIsLoading,\n      initialMessages,\n      isLoading,\n      actions,\n      onFunctionCall,\n      onCoAgentStateRender,\n      setCoagentStatesWithRef,\n      coagentStatesRef,\n      agentSession,\n      setAgentSession,\n    ],\n  );\n\n  runChatCompletionRef.current = runChatCompletion;\n\n  const runChatCompletionAndHandleFunctionCall = useAsyncCallback(\n    async (messages: Message[]): Promise<void> => {\n      await runChatCompletionRef.current!(messages);\n    },\n    [messages],\n  );\n\n  // Go over all events and see that they include data that should be returned to the agent\n  const composeAndFlushMetaEventsInput = useCallback(\n    (metaEvents: (MetaEvent | undefined | null)[]) => {\n      return metaEvents.reduce((acc: MetaEventInput[], event) => {\n        if (!event) return acc;\n\n        switch (event.name) {\n          case MetaEventName.LangGraphInterruptEvent:\n            if (event.response) {\n              // Flush interrupt event from state\n              setLangGraphInterruptAction(null);\n              const value = (event as LangGraphInterruptEvent).value;\n              return [\n                ...acc,\n                {\n                  name: event.name,\n                  value: typeof value === \"string\" ? value : JSON.stringify(value),\n                  response:\n                    typeof event.response === \"string\"\n                      ? event.response\n                      : JSON.stringify(event.response),\n                },\n              ];\n            }\n            return acc;\n          default:\n            return acc;\n        }\n      }, []);\n    },\n    [setLangGraphInterruptAction],\n  );\n\n  const append = useAsyncCallback(\n    async (message: Message, options?: AppendMessageOptions): Promise<void> => {\n      if (isLoading) {\n        return;\n      }\n\n      const newMessages = [...messages, message];\n      setMessages(newMessages);\n      const followUp = options?.followUp ?? true;\n      if (followUp) {\n        return runChatCompletionAndHandleFunctionCall(newMessages);\n      }\n    },\n    [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall],\n  );\n\n  const reload = useAsyncCallback(async (): Promise<void> => {\n    if (isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage.isTextMessage() && lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  }, [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]);\n\n  const stop = (): void => {\n    chatAbortControllerRef.current?.abort(\"Stop was called\");\n  };\n\n  return {\n    append,\n    reload,\n    stop,\n    runChatCompletion: () => runChatCompletionRef.current!(messages),\n  };\n}\n\nfunction constructFinalMessages(\n  syncedMessages: Message[],\n  previousMessages: Message[],\n  newMessages: Message[],\n): Message[] {\n  const finalMessages =\n    syncedMessages.length > 0 ? [...syncedMessages] : [...previousMessages, ...newMessages];\n\n  if (syncedMessages.length > 0) {\n    const messagesWithAgentState = [...previousMessages, ...newMessages];\n\n    let previousMessageId: string | undefined = undefined;\n\n    for (const message of messagesWithAgentState) {\n      if (message.isAgentStateMessage()) {\n        // insert this message into finalMessages after the position of previousMessageId\n        const index = finalMessages.findIndex((msg) => msg.id === previousMessageId);\n        if (index !== -1) {\n          finalMessages.splice(index + 1, 0, message);\n        }\n      }\n\n      previousMessageId = message.id;\n    }\n  }\n\n  return finalMessages;\n}\n\nasync function executeAction({\n  onFunctionCall,\n  previousMessages,\n  message,\n  chatAbortControllerRef,\n  onError,\n}: {\n  onFunctionCall: FunctionCallHandler;\n  previousMessages: Message[];\n  message: ActionExecutionMessage;\n  chatAbortControllerRef: React.MutableRefObject<AbortController | null>;\n  onError: (error: Error) => void;\n}) {\n  let result: any;\n  let error: Error | null = null;\n  try {\n    result = await Promise.race([\n      onFunctionCall({\n        messages: previousMessages,\n        name: message.name,\n        args: message.arguments,\n      }),\n      new Promise((resolve) =>\n        chatAbortControllerRef.current?.signal.addEventListener(\"abort\", () =>\n          resolve(\"Operation was aborted by the user\"),\n        ),\n      ),\n      // if the user stopped generation, we also abort consecutive actions\n      new Promise((resolve) => {\n        if (chatAbortControllerRef.current?.signal.aborted) {\n          resolve(\"Operation was aborted by the user\");\n        }\n      }),\n    ]);\n  } catch (e) {\n    onError(e as Error);\n  }\n  return new ResultMessage({\n    id: \"result-\" + message.id,\n    result: ResultMessage.encodeResult(\n      error\n        ? {\n            content: result,\n            error: JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error))),\n          }\n        : result,\n    ),\n    actionExecutionId: message.id,\n    actionName: message.name,\n  });\n}\n\nfunction getPairedFeAction(\n  actions: FrontendAction<any>[],\n  message: ActionExecutionMessage | ResultMessage,\n) {\n  let actionName = null;\n  if (message.isActionExecutionMessage()) {\n    actionName = message.name;\n  } else if (message.isResultMessage()) {\n    actionName = message.actionName;\n  }\n  return actions.find(\n    (action) =>\n      (action.name === actionName && action.available === \"frontend\") ||\n      action.pairedAction === actionName,\n  );\n}\n"],"names":["_a","messages","action","message","options"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2706, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2712, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-copilot-chat.ts"],"sourcesContent":["/**\n * `useCopilotChat` is a React hook that lets you directly interact with the\n * Copilot instance. Use to implement a fully custom UI (headless UI) or to\n * programmatically interact with the Copilot instance managed by the default\n * UI.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * import { useCopilotChat } from \"@copilotkit/react-core\";\n * import { Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\n *\n * export function YourComponent() {\n *   const { appendMessage } = useCopilotChat();\n *\n *   appendMessage(\n *     new TextMessage({\n *       content: \"Hello World\",\n *       role: Role.User,\n *     }),\n *   );\n *\n *   // optionally, you can append a message without running chat completion\n *   appendMessage(yourMessage, { followUp: false });\n * }\n * ```\n *\n * `useCopilotChat` returns an object with the following properties:\n *\n * ```tsx\n * const {\n *   visibleMessages, // An array of messages that are currently visible in the chat.\n *   appendMessage, // A function to append a message to the chat.\n *   setMessages, // A function to set the messages in the chat.\n *   deleteMessage, // A function to delete a message from the chat.\n *   reloadMessages, // A function to reload the messages from the API.\n *   stopGeneration, // A function to stop the generation of the next message.\n *   reset, // A function to reset the chat.\n *   isLoading, // A boolean indicating if the chat is loading.\n * } = useCopilotChat();\n * ```\n */\nimport { useRef, useEffect, useCallback } from \"react\";\nimport { AgentSession, useCopilotContext } from \"../context/copilot-context\";\nimport { Message, Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\nimport { SystemMessageFunction } from \"../types\";\nimport { useChat, AppendMessageOptions } from \"./use-chat\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { CoAgentStateRenderHandlerArguments } from \"@copilotkit/shared\";\nimport { useCopilotMessagesContext } from \"../context\";\nimport { useAsyncCallback } from \"../components/error-boundary/error-utils\";\n\nexport interface UseCopilotChatOptions {\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n\n  /**\n   * A function to generate the system message. Defaults to `defaultSystemMessage`.\n   */\n  makeSystemMessage?: SystemMessageFunction;\n}\n\nexport interface UseCopilotChatReturn {\n  visibleMessages: Message[];\n  appendMessage: (message: Message, options?: AppendMessageOptions) => Promise<void>;\n  setMessages: (messages: Message[]) => void;\n  deleteMessage: (messageId: string) => void;\n  reloadMessages: () => Promise<void>;\n  stopGeneration: () => void;\n  reset: () => void;\n  isLoading: boolean;\n  runChatCompletion: () => Promise<Message[]>;\n}\n\nexport function useCopilotChat({\n  makeSystemMessage,\n  ...options\n}: UseCopilotChatOptions = {}): UseCopilotChatReturn {\n  const {\n    getContextString,\n    getFunctionCallHandler,\n    copilotApiConfig,\n    isLoading,\n    setIsLoading,\n    chatInstructions,\n    actions,\n    coagentStatesRef,\n    setCoagentStatesWithRef,\n    coAgentStateRenders,\n    agentSession,\n    setAgentSession,\n    forwardedParameters,\n    agentLock,\n    threadId,\n    setThreadId,\n    runId,\n    setRunId,\n    chatAbortControllerRef,\n    extensions,\n    setExtensions,\n    langGraphInterruptAction,\n    setLangGraphInterruptAction,\n  } = useCopilotContext();\n  const { messages, setMessages } = useCopilotMessagesContext();\n\n  // We need to ensure that makeSystemMessageCallback always uses the latest\n  // useCopilotReadable data.\n  const latestGetContextString = useUpdatedRef(getContextString);\n  const deleteMessage = useCallback(\n    (messageId: string) => {\n      setMessages((prev) => prev.filter((message) => message.id !== messageId));\n    },\n    [setMessages],\n  );\n\n  const makeSystemMessageCallback = useCallback(() => {\n    const systemMessageMaker = makeSystemMessage || defaultSystemMessage;\n    // this always gets the latest context string\n    const contextString = latestGetContextString.current([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return new TextMessage({\n      content: systemMessageMaker(contextString, chatInstructions),\n      role: Role.System,\n    });\n  }, [getContextString, makeSystemMessage, chatInstructions]);\n\n  const onCoAgentStateRender = useAsyncCallback(\n    async (args: CoAgentStateRenderHandlerArguments) => {\n      const { name, nodeName, state } = args;\n      let action = Object.values(coAgentStateRenders).find(\n        (action) => action.name === name && action.nodeName === nodeName,\n      );\n      if (!action) {\n        action = Object.values(coAgentStateRenders).find(\n          (action) => action.name === name && !action.nodeName,\n        );\n      }\n      if (action) {\n        await action.handler?.({ state, nodeName });\n      }\n    },\n    [coAgentStateRenders],\n  );\n\n  const { append, reload, stop, runChatCompletion } = useChat({\n    ...options,\n    actions: Object.values(actions),\n    copilotConfig: copilotApiConfig,\n    initialMessages: options.initialMessages || [],\n    onFunctionCall: getFunctionCallHandler(),\n    onCoAgentStateRender,\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    isLoading,\n    setIsLoading,\n    coagentStatesRef,\n    setCoagentStatesWithRef,\n    agentSession,\n    setAgentSession,\n    forwardedParameters,\n    threadId,\n    setThreadId,\n    runId,\n    setRunId,\n    chatAbortControllerRef,\n    agentLock,\n    extensions,\n    setExtensions,\n    langGraphInterruptAction,\n    setLangGraphInterruptAction,\n  });\n\n  // this is a workaround born out of a bug that Athena incessantly ran into.\n  // We could not find the origin of the bug, however, it was clear that an outdated version of the append function was being used somehow --\n  // it referenced the old state of the messages array, and not the latest one.\n  //\n  // We want to make copilotkit as abuse-proof as possible, so we are adding this workaround to ensure that the latest version of the append function is always used.\n  //\n  // How does this work?\n  // we store the relevant function in a ref that is always up-to-date, and then we use that ref in the callback.\n  const latestAppend = useUpdatedRef(append);\n  const latestAppendFunc = useAsyncCallback(\n    async (message: Message, options?: AppendMessageOptions) => {\n      return await latestAppend.current(message, options);\n    },\n    [latestAppend],\n  );\n\n  const latestReload = useUpdatedRef(reload);\n  const latestReloadFunc = useAsyncCallback(async () => {\n    return await latestReload.current();\n  }, [latestReload]);\n\n  const latestStop = useUpdatedRef(stop);\n  const latestStopFunc = useCallback(() => {\n    return latestStop.current();\n  }, [latestStop]);\n\n  const latestDelete = useUpdatedRef(deleteMessage);\n  const latestDeleteFunc = useCallback(\n    (messageId: string) => {\n      return latestDelete.current(messageId);\n    },\n    [latestDelete],\n  );\n\n  const latestSetMessages = useUpdatedRef(setMessages);\n  const latestSetMessagesFunc = useCallback(\n    (messages: Message[]) => {\n      return latestSetMessages.current(messages);\n    },\n    [latestSetMessages],\n  );\n\n  const latestRunChatCompletion = useUpdatedRef(runChatCompletion);\n  const latestRunChatCompletionFunc = useAsyncCallback(async () => {\n    return await latestRunChatCompletion.current!();\n  }, [latestRunChatCompletion]);\n\n  const reset = useCallback(() => {\n    latestStopFunc();\n    setMessages([]);\n    setRunId(null);\n    setCoagentStatesWithRef({});\n    let initialAgentSession: AgentSession | null = null;\n    if (agentLock) {\n      initialAgentSession = {\n        agentName: agentLock,\n      };\n    }\n    setAgentSession(initialAgentSession);\n  }, [\n    latestStopFunc,\n    setMessages,\n    setThreadId,\n    setCoagentStatesWithRef,\n    setAgentSession,\n    agentLock,\n  ]);\n\n  const latestReset = useUpdatedRef(reset);\n  const latestResetFunc = useCallback(() => {\n    return latestReset.current();\n  }, [latestReset]);\n\n  return {\n    visibleMessages: messages,\n    appendMessage: latestAppendFunc,\n    setMessages: latestSetMessagesFunc,\n    reloadMessages: latestReloadFunc,\n    stopGeneration: latestStopFunc,\n    reset: latestResetFunc,\n    deleteMessage: latestDeleteFunc,\n    runChatCompletion: latestRunChatCompletionFunc,\n    isLoading,\n  };\n}\n\n// store `value` in a ref and update\n// it whenever it changes.\nfunction useUpdatedRef<T>(value: T) {\n  const ref = useRef(value);\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref;\n}\n\nexport function defaultSystemMessage(\n  contextString: string,\n  additionalInstructions?: string,\n): string {\n  return (\n    `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\nIn case of a function error:\n- If this error stems from incorrect function parameters or syntax, you may retry with corrected arguments.\n- If the error's source is unclear or seems unrelated to your input, do not attempt further retries.\n` + (additionalInstructions ? `\\n\\n${additionalInstructions}` : \"\")\n  );\n}\n"],"names":["_a","action","options","messages"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2951, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2957, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-langgraph-interrupt.ts"],"sourcesContent":["import { useContext, useEffect, useMemo } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { LangGraphInterruptRender } from \"../types/interrupt-action\";\nimport { useCopilotChat } from \"./use-copilot-chat\";\nimport { useToast } from \"../components/toast/toast-provider\";\nimport { dataToUUID } from \"@copilotkit/shared\";\n\nexport function useLangGraphInterrupt<TEventValue = any>(\n  action: Omit<LangGraphInterruptRender<TEventValue>, \"id\">,\n  dependencies?: any[],\n) {\n  const { setLangGraphInterruptAction, removeLangGraphInterruptAction, langGraphInterruptAction } =\n    useContext(CopilotContext);\n  const { runChatCompletion } = useCopilotChat();\n  const { addToast } = useToast();\n\n  const actionId = dataToUUID(JSON.stringify(action), \"lgAction\");\n  // We only consider action to be defined once the ID is there\n  const hasAction = useMemo(\n    () => Boolean(langGraphInterruptAction?.id),\n    [langGraphInterruptAction],\n  );\n\n  const isCurrentAction = useMemo(\n    () => langGraphInterruptAction?.id && langGraphInterruptAction?.id === actionId,\n    [langGraphInterruptAction],\n  );\n\n  // Run chat completion to submit a response event. Only if it's the current action\n  useEffect(() => {\n    if (hasAction && isCurrentAction && langGraphInterruptAction?.event?.response) {\n      runChatCompletion();\n    }\n  }, [langGraphInterruptAction?.event?.response, runChatCompletion, hasAction, isCurrentAction]);\n\n  useEffect(() => {\n    if (!action) return;\n    // An action was already set, with no conditions and it's not the action we're using right now.\n    // Show a warning, as this action will not be executed\n    if (hasAction && !isCurrentAction && !action.enabled) {\n      addToast({\n        type: \"warning\",\n        message: \"An action is already registered for the interrupt event\",\n      });\n      return;\n    }\n\n    if (hasAction && isCurrentAction) {\n      return;\n    }\n\n    setLangGraphInterruptAction({ ...action, id: actionId });\n  }, [\n    action,\n    hasAction,\n    isCurrentAction,\n    setLangGraphInterruptAction,\n    removeLangGraphInterruptAction,\n    ...(dependencies || []),\n  ]);\n}\n"],"names":["_a"],"mappings":";;;;;;;;AAAA,SAAS,YAAY,WAAW,eAAe;AAK/C,SAAS,kBAAkB;;;;;;;AAEpB,SAAS,sBACd,MAAA,EACA,YAAA,EACA;IAVF,IAAA;IAWE,MAAM,EAAE,2BAAA,EAA6B,8BAAA,EAAgC,wBAAA,CAAyB,CAAA,IAC5F,8KAAA,iLAAW,iBAAc;IAC3B,MAAM,EAAE,iBAAA,CAAkB,CAAA,OAAI,gMAAA,CAAe;IAC7C,MAAM,EAAE,QAAA,CAAS,CAAA,sLAAI,WAAA,CAAS;IAE9B,MAAM,WAAW,yLAAA,EAAW,KAAK,SAAA,CAAU,MAAM,GAAG,UAAU;IAE9D,MAAM,YAAY,4KAAA;oDAChB,IAAM,QAAQ,4BAAA,OAAA,KAAA,IAAA,yBAA0B,EAAE;mDAC1C;QAAC,wBAAwB;KAAA;IAG3B,MAAM,oLAAkB,UAAA;0DACtB,IAAA,CAAM,4BAAA,OAAA,KAAA,IAAA,yBAA0B,EAAA,KAAA,CAAM,4BAAA,OAAA,KAAA,IAAA,yBAA0B,EAAA,MAAO;yDACvE;QAAC,wBAAwB;KAAA;IAI3B,CAAA,GAAA,6JAAA,CAAA,YAAA;2CAAU,MAAM;YA7BlB,IAAAA;YA8BI,IAAI,aAAa,mBAAA,CAAA,CAAmBA,MAAA,4BAAA,OAAA,KAAA,IAAA,yBAA0B,KAAA,KAA1B,OAAA,KAAA,IAAAA,IAAiC,QAAA,GAAU;gBAC7E,kBAAkB;YACpB;QACF;0CAAG;QAAA,CAAC,KAAA,4BAAA,OAAA,KAAA,IAAA,yBAA0B,KAAA,KAA1B,OAAA,KAAA,IAAA,GAAiC,QAAA;QAAU;QAAmB;QAAW,eAAe;KAAC;IAE7F,CAAA,GAAA,6JAAA,CAAA,YAAA;2CAAU,MAAM;YACd,IAAI,CAAC,QAAQ;YAGb,IAAI,aAAa,CAAC,mBAAmB,CAAC,OAAO,OAAA,EAAS;gBACpD,SAAS;oBACP,MAAM;oBACN,SAAS;gBACX,CAAC;gBACD;YACF;YAEA,IAAI,aAAa,iBAAiB;gBAChC;YACF;YAEA,+MAA4B,gBAAA,EAAA,CAAA,GAAA,8KAAA,CAAA,iBAAA,EAAA,CAAA,GAAK,SAAL;gBAAa,IAAI;YAAS,EAAC;QACzD;0CAAG;QACD;QACA;QACA;QACA;QACA;WACI,gBAAgB,CAAC,CAAA;KACtB;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3030, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3036, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-make-copilot-document-readable.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { DocumentPointer } from \"../types\";\n\n/**\n * Makes a document readable by Copilot.\n * @param document The document to make readable.\n * @param categories The categories to associate with the document.\n * @param dependencies The dependencies to use for the effect.\n * @returns The id of the document.\n */\nexport function useMakeCopilotDocumentReadable(\n  document: DocumentPointer,\n  categories?: string[],\n  dependencies: any[] = [],\n): string | undefined {\n  const { addDocumentContext, removeDocumentContext } = useCopilotContext();\n  const idRef = useRef<string>();\n\n  useEffect(() => {\n    const id = addDocumentContext(document, categories);\n    idRef.current = id;\n\n    return () => {\n      removeDocumentContext(id);\n    };\n  }, [addDocumentContext, removeDocumentContext, ...dependencies]);\n\n  return idRef.current;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,WAAW,cAAc;;;AAW3B,SAAS,+BACd,QAAA,EACA,UAAA,EACA,eAAsB,CAAC,CAAA,EACH;IACpB,MAAM,EAAE,kBAAA,EAAoB,qBAAA,CAAsB,CAAA,sLAAI,oBAAA,CAAkB;IACxE,MAAM,0KAAQ,SAAA,CAAe;IAE7B,CAAA,GAAA,6JAAA,CAAA,YAAA;oDAAU,MAAM;YACd,MAAM,KAAK,mBAAmB,UAAU,UAAU;YAClD,MAAM,OAAA,GAAU;YAEhB;4DAAO,MAAM;oBACX,sBAAsB,EAAE;gBAC1B;;QACF;mDAAG;QAAC;QAAoB,uBAAuB;WAAG,YAAY;KAAC;IAE/D,OAAO,MAAM,OAAA;AACf","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3066, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3072, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-coagent-state-render.ts"],"sourcesContent":["/**\n * The useCoAgentStateRender hook allows you to render UI or text based components on a Agentic Copilot's state in the chat.\n * This is particularly useful for showing intermediate state or progress during Agentic Copilot operations.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * import { useCoAgentStateRender } from \"@copilotkit/react-core\";\n *\n * type YourAgentState = {\n *   agent_state_property: string;\n * }\n *\n * useCoAgentStateRender<YourAgentState>({\n *   name: \"basic_agent\",\n *   nodeName: \"optionally_specify_a_specific_node\",\n *   render: ({ status, state, nodeName }) => {\n *     return (\n *       <YourComponent\n *         agentStateProperty={state.agent_state_property}\n *         status={status}\n *         nodeName={nodeName}\n *       />\n *     );\n *   },\n * });\n * ```\n *\n * This allows for you to render UI components or text based on what is happening within the agent.\n *\n * ### Example\n * A great example of this is in our Perplexity Clone where we render the progress of an agent's internet search as it is happening.\n * You can play around with it below or learn how to build it with its [demo](/coagents/videos/perplexity-clone).\n *\n * <Callout type=\"info\">\n *   This example is hosted on Vercel and may take a few seconds to load.\n * </Callout>\n *\n * <iframe src=\"https://examples-coagents-ai-researcher-ui.vercel.app/\" className=\"w-full rounded-lg border h-[700px] my-4\" />\n */\n\nimport { useRef, useContext, useEffect } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { randomId } from \"@copilotkit/shared\";\nimport { CoAgentStateRender } from \"../types/coagent-action\";\nimport { useToast } from \"../components/toast/toast-provider\";\n\n/**\n * This hook is used to render agent state with custom UI components or text. This is particularly\n * useful for showing intermediate state or progress during Agentic Copilot operations.\n * To get started using rendering intermediate state through this hook, checkout the documentation.\n *\n * https://docs.copilotkit.ai/coagents/shared-state/predictive-state-updates\n */\n\n// We implement useCoAgentStateRender dependency handling so that\n// the developer has the option to not provide any dependencies.\n// see useCopilotAction for more details about this approach.\nexport function useCoAgentStateRender<T = any>(\n  action: CoAgentStateRender<T>,\n  dependencies?: any[],\n): void {\n  const {\n    setCoAgentStateRender,\n    removeCoAgentStateRender,\n    coAgentStateRenders,\n    chatComponentsCache,\n    availableAgents,\n  } = useContext(CopilotContext);\n  const idRef = useRef<string>(randomId());\n  const { addToast } = useToast();\n\n  useEffect(() => {\n    if (availableAgents?.length && !availableAgents.some((a) => a.name === action.name)) {\n      const message = `(useCoAgentStateRender): Agent \"${action.name}\" not found. Make sure the agent exists and is properly configured.`;\n      addToast({ type: \"warning\", message });\n    }\n  }, [availableAgents]);\n\n  const key = `${action.name}-${action.nodeName || \"global\"}`;\n\n  if (dependencies === undefined) {\n    if (coAgentStateRenders[idRef.current]) {\n      coAgentStateRenders[idRef.current].handler = action.handler as any;\n      if (typeof action.render === \"function\") {\n        if (chatComponentsCache.current !== null) {\n          chatComponentsCache.current.coAgentStateRenders[key] = action.render;\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    // Check for duplicates by comparing against all other actions\n    const currentId = idRef.current;\n    const hasDuplicate = Object.entries(coAgentStateRenders).some(([id, otherAction]) => {\n      // Skip comparing with self\n      if (id === currentId) return false;\n\n      // Different agent names are never duplicates\n      if (otherAction.name !== action.name) return false;\n\n      // Same agent names:\n      const hasNodeName = !!action.nodeName;\n      const hasOtherNodeName = !!otherAction.nodeName;\n\n      // If neither has nodeName, they're duplicates\n      if (!hasNodeName && !hasOtherNodeName) return true;\n\n      // If one has nodeName and other doesn't, they're not duplicates\n      if (hasNodeName !== hasOtherNodeName) return false;\n\n      // If both have nodeName, they're duplicates only if the names match\n      return action.nodeName === otherAction.nodeName;\n    });\n\n    if (hasDuplicate) {\n      const message = action.nodeName\n        ? `Found multiple state renders for agent ${action.name} and node ${action.nodeName}. State renders might get overridden`\n        : `Found multiple state renders for agent ${action.name}. State renders might get overridden`;\n\n      addToast({\n        type: \"warning\",\n        message,\n        id: `dup-action-${action.name}`,\n      });\n    }\n  }, [coAgentStateRenders]);\n\n  useEffect(() => {\n    setCoAgentStateRender(idRef.current, action as any);\n    if (chatComponentsCache.current !== null && action.render !== undefined) {\n      chatComponentsCache.current.coAgentStateRenders[key] = action.render;\n    }\n    return () => {\n      removeCoAgentStateRender(idRef.current);\n    };\n  }, [\n    setCoAgentStateRender,\n    removeCoAgentStateRender,\n    action.name,\n    // include render only if it's a string\n    typeof action.render === \"string\" ? action.render : undefined,\n    // dependencies set by the developer\n    ...(dependencies || []),\n  ]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3164, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3170, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-coagent.ts"],"sourcesContent":["/**\n * <Callout type=\"info\">\n *   Usage of this hook assumes some additional setup in your application, for more information\n *   on that see the CoAgents <span className=\"text-blue-500\">[getting started guide](/coagents/quickstart/langgraph)</span>.\n * </Callout>\n * <Frame className=\"my-12\">\n *   <img\n *     src=\"/images/coagents/SharedStateCoAgents.gif\"\n *     alt=\"CoAgents demonstration\"\n *     className=\"w-auto\"\n *   />\n * </Frame>\n *\n * This hook is used to integrate an agent into your application. With its use, you can\n * render and update the state of an agent, allowing for a dynamic and interactive experience.\n * We call these shared state experiences agentic copilots, or CoAgents for short.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * import { useCoAgent } from \"@copilotkit/react-core\";\n *\n * type AgentState = {\n *   count: number;\n * }\n *\n * const agent = useCoAgent<AgentState>({\n *   name: \"my-agent\",\n *   initialState: {\n *     count: 0,\n *   },\n * });\n *\n * ```\n *\n * `useCoAgent` returns an object with the following properties:\n *\n * ```tsx\n * const {\n *   name,     // The name of the agent currently being used.\n *   nodeName, // The name of the current LangGraph node.\n *   state,    // The current state of the agent.\n *   setState, // A function to update the state of the agent.\n *   running,  // A boolean indicating if the agent is currently running.\n *   start,    // A function to start the agent.\n *   stop,     // A function to stop the agent.\n *   run,      // A function to re-run the agent. Takes a HintFunction to inform the agent why it is being re-run.\n * } = agent;\n * ```\n *\n * Finally we can leverage these properties to create reactive experiences with the agent!\n *\n * ```tsx\n * const { state, setState } = useCoAgent<AgentState>({\n *   name: \"my-agent\",\n *   initialState: {\n *     count: 0,\n *   },\n * });\n *\n * return (\n *   <div>\n *     <p>Count: {state.count}</p>\n *     <button onClick={() => setState({ count: state.count + 1 })}>Increment</button>\n *   </div>\n * );\n * ```\n *\n * This reactivity is bidirectional, meaning that changes to the state from the agent will be reflected in the UI and vice versa.\n *\n * ## Parameters\n * <PropertyReference name=\"options\" type=\"UseCoagentOptions<T>\" required>\n *   The options to use when creating the coagent.\n *   <PropertyReference name=\"name\" type=\"string\" required>\n *     The name of the agent to use.\n *   </PropertyReference>\n *   <PropertyReference name=\"initialState\" type=\"T | any\">\n *     The initial state of the agent.\n *   </PropertyReference>\n *   <PropertyReference name=\"state\" type=\"T | any\">\n *     State to manage externally if you are using this hook with external state management.\n *   </PropertyReference>\n *   <PropertyReference name=\"setState\" type=\"(newState: T | ((prevState: T | undefined) => T)) => void\">\n *     A function to update the state of the agent if you are using this hook with external state management.\n *   </PropertyReference>\n * </PropertyReference>\n */\n\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport {\n  CopilotContextParams,\n  CopilotMessagesContextParams,\n  useCopilotContext,\n  useCopilotMessagesContext,\n} from \"../context\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport { useCopilotChat } from \"./use-copilot-chat\";\nimport { Message } from \"@copilotkit/runtime-client-gql\";\nimport { useAsyncCallback } from \"../components/error-boundary/error-utils\";\nimport { useToast } from \"../components/toast/toast-provider\";\nimport { useCopilotRuntimeClient } from \"./use-copilot-runtime-client\";\nimport { parseJson } from \"@copilotkit/shared\";\n\ninterface WithInternalStateManagementAndInitial<T> {\n  /**\n   * The name of the agent being used.\n   */\n  name: string;\n  /**\n   * The initial state of the agent.\n   */\n  initialState: T;\n  /**\n   * Config to pass to a LangGraph Agent\n   */\n  configurable?: Record<string, any>;\n}\n\ninterface WithInternalStateManagement {\n  /**\n   * The name of the agent being used.\n   */\n  name: string;\n  /**\n   * Optional initialState with default type any\n   */\n  initialState?: any;\n  /**\n   * Config to pass to a LangGraph Agent\n   */\n  configurable?: Record<string, any>;\n}\n\ninterface WithExternalStateManagement<T> {\n  /**\n   * The name of the agent being used.\n   */\n  name: string;\n  /**\n   * The current state of the agent.\n   */\n  state: T;\n  /**\n   * A function to update the state of the agent.\n   */\n  setState: (newState: T | ((prevState: T | undefined) => T)) => void;\n  /**\n   * Config to pass to a LangGraph Agent\n   */\n  configurable?: Record<string, any>;\n}\n\ntype UseCoagentOptions<T> =\n  | WithInternalStateManagementAndInitial<T>\n  | WithInternalStateManagement\n  | WithExternalStateManagement<T>;\n\nexport interface UseCoagentReturnType<T> {\n  /**\n   * The name of the agent being used.\n   */\n  name: string;\n  /**\n   * The name of the current LangGraph node.\n   */\n  nodeName?: string;\n  /**\n   * The ID of the thread the agent is running in.\n   */\n  threadId?: string;\n  /**\n   * A boolean indicating if the agent is currently running.\n   */\n  running: boolean;\n  /**\n   * The current state of the agent.\n   */\n  state: T;\n  /**\n   * A function to update the state of the agent.\n   */\n  setState: (newState: T | ((prevState: T | undefined) => T)) => void;\n  /**\n   * A function to start the agent.\n   */\n  start: () => void;\n  /**\n   * A function to stop the agent.\n   */\n  stop: () => void;\n  /**\n   * A function to re-run the agent. The hint function can be used to provide a hint to the agent\n   * about why it is being re-run again.\n   */\n  run: (hint?: HintFunction) => Promise<void>;\n}\n\nexport interface HintFunctionParams {\n  /**\n   * The previous state of the agent.\n   */\n  previousState: any;\n  /**\n   * The current state of the agent.\n   */\n  currentState: any;\n}\n\nexport type HintFunction = (params: HintFunctionParams) => Message | undefined;\n\n/**\n * This hook is used to integrate an agent into your application. With its use, you can\n * render and update the state of the agent, allowing for a dynamic and interactive experience.\n * We call these shared state experiences \"agentic copilots\". To get started using agentic copilots, which\n * we refer to as CoAgents, checkout the documentation at https://docs.copilotkit.ai/coagents/quickstart/langgraph.\n */\nexport function useCoAgent<T = any>(options: UseCoagentOptions<T>): UseCoagentReturnType<T> {\n  const generalContext = useCopilotContext();\n  const { availableAgents } = generalContext;\n  const { addToast } = useToast();\n  const lastLoadedThreadId = useRef<string>();\n  const lastLoadedState = useRef<any>();\n\n  const { name } = options;\n  useEffect(() => {\n    if (availableAgents?.length && !availableAgents.some((a) => a.name === name)) {\n      const message = `(useCoAgent): Agent \"${name}\" not found. Make sure the agent exists and is properly configured.`;\n      console.warn(message);\n      addToast({ type: \"warning\", message });\n    }\n  }, [availableAgents]);\n\n  const messagesContext = useCopilotMessagesContext();\n  const context = { ...generalContext, ...messagesContext };\n  const { coagentStates, coagentStatesRef, setCoagentStatesWithRef, threadId, copilotApiConfig } =\n    context;\n  const { appendMessage, runChatCompletion } = useCopilotChat();\n\n  const runtimeClient = useCopilotRuntimeClient({\n    url: copilotApiConfig.chatApiEndpoint,\n    publicApiKey: copilotApiConfig.publicApiKey,\n    credentials: copilotApiConfig.credentials,\n  });\n\n  // if we manage state internally, we need to provide a function to set the state\n  const setState = useCallback(\n    (newState: T | ((prevState: T | undefined) => T)) => {\n      // coagentStatesRef.current || {}\n      let coagentState: CoagentState = getCoagentState({ coagentStates, name, options });\n      const updatedState =\n        typeof newState === \"function\" ? (newState as Function)(coagentState.state) : newState;\n\n      setCoagentStatesWithRef({\n        ...coagentStatesRef.current,\n        [name]: {\n          ...coagentState,\n          state: updatedState,\n        },\n      });\n    },\n    [coagentStates, name],\n  );\n\n  useEffect(() => {\n    const fetchAgentState = async () => {\n      if (!threadId || threadId === lastLoadedThreadId.current) return;\n\n      const result = await runtimeClient.loadAgentState({\n        threadId,\n        agentName: name,\n      });\n\n      const newState = result.data?.loadAgentState?.state;\n      if (newState === lastLoadedState.current) return;\n\n      if (result.data?.loadAgentState?.threadExists && newState && newState != \"{}\") {\n        lastLoadedState.current = newState;\n        lastLoadedThreadId.current = threadId;\n        const fetchedState = parseJson(newState, {});\n        isExternalStateManagement(options)\n          ? options.setState(fetchedState)\n          : setState(fetchedState);\n      }\n    };\n    void fetchAgentState();\n  }, [threadId]);\n\n  // Sync internal state with external state if state management is external\n  useEffect(() => {\n    if (isExternalStateManagement(options)) {\n      setState(options.state);\n    } else if (coagentStates[name] === undefined) {\n      setState(options.initialState === undefined ? {} : options.initialState);\n    }\n  }, [\n    isExternalStateManagement(options) ? JSON.stringify(options.state) : undefined,\n    // reset initialstate on reset\n    coagentStates[name] === undefined,\n  ]);\n\n  const runAgentCallback = useAsyncCallback(\n    async (hint?: HintFunction) => {\n      await runAgent(name, context, appendMessage, runChatCompletion, hint);\n    },\n    [name, context, appendMessage, runChatCompletion],\n  );\n\n  // Return the state and setState function\n  return useMemo(() => {\n    const coagentState = getCoagentState({ coagentStates, name, options });\n    return {\n      name,\n      nodeName: coagentState.nodeName,\n      threadId: coagentState.threadId,\n      running: coagentState.running,\n      state: coagentState.state,\n      setState: isExternalStateManagement(options) ? options.setState : setState,\n      start: () => startAgent(name, context),\n      stop: () => stopAgent(name, context),\n      run: runAgentCallback,\n    };\n  }, [name, coagentStates, options, setState, runAgentCallback]);\n}\n\nexport function startAgent(name: string, context: CopilotContextParams) {\n  const { setAgentSession } = context;\n  setAgentSession({\n    agentName: name,\n  });\n}\n\nexport function stopAgent(name: string, context: CopilotContextParams) {\n  const { agentSession, setAgentSession } = context;\n  if (agentSession && agentSession.agentName === name) {\n    setAgentSession(null);\n    context.setCoagentStates((prevAgentStates) => {\n      return {\n        ...prevAgentStates,\n        [name]: {\n          ...prevAgentStates[name],\n          running: false,\n          active: false,\n          threadId: undefined,\n          nodeName: undefined,\n          runId: undefined,\n        },\n      };\n    });\n  } else {\n    console.warn(`No agent session found for ${name}`);\n  }\n}\n\nexport async function runAgent(\n  name: string,\n  context: CopilotContextParams & CopilotMessagesContextParams,\n  appendMessage: (message: Message) => Promise<void>,\n  runChatCompletion: () => Promise<Message[]>,\n  hint?: HintFunction,\n) {\n  const { agentSession, setAgentSession } = context;\n  if (!agentSession || agentSession.agentName !== name) {\n    setAgentSession({\n      agentName: name,\n    });\n  }\n\n  let previousState: any = null;\n  for (let i = context.messages.length - 1; i >= 0; i--) {\n    const message = context.messages[i];\n    if (message.isAgentStateMessage() && message.agentName === name) {\n      previousState = message.state;\n    }\n  }\n\n  let state = context.coagentStatesRef.current?.[name]?.state || {};\n\n  if (hint) {\n    const hintMessage = hint({ previousState, currentState: state });\n    if (hintMessage) {\n      await appendMessage(hintMessage);\n    } else {\n      await runChatCompletion();\n    }\n  } else {\n    await runChatCompletion();\n  }\n}\n\nconst isExternalStateManagement = <T>(\n  options: UseCoagentOptions<T>,\n): options is WithExternalStateManagement<T> => {\n  return \"state\" in options && \"setState\" in options;\n};\n\nconst isInternalStateManagementWithInitial = <T>(\n  options: UseCoagentOptions<T>,\n): options is WithInternalStateManagementAndInitial<T> => {\n  return \"initialState\" in options;\n};\n\nconst getCoagentState = <T>({\n  coagentStates,\n  name,\n  options,\n}: {\n  coagentStates: Record<string, CoagentState>;\n  name: string;\n  options: UseCoagentOptions<T>;\n}) => {\n  if (coagentStates[name]) {\n    return coagentStates[name];\n  } else {\n    return {\n      name,\n      state: isInternalStateManagementWithInitial<T>(options) ? options.initialState : {},\n      configurable: options.configurable ?? {},\n      running: false,\n      active: false,\n      threadId: undefined,\n      nodeName: undefined,\n      runId: undefined,\n    };\n  }\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3408, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3414, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-copilot-additional-instructions.ts"],"sourcesContent":["/**\n * `useCopilotAdditionalInstructions` is a React hook that provides additional instructions\n * to the Copilot.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * In its most basic usage, useCopilotAdditionalInstructions accepts a single string argument\n * representing the instructions to be added to the Copilot.\n *\n * ```tsx\n * import { useCopilotAdditionalInstructions } from \"@copilotkit/react-core\";\n *\n * export function MyComponent() {\n *   useCopilotAdditionalInstructions({\n *     instructions: \"Do not answer questions about the weather.\",\n *   });\n * }\n * ```\n *\n * ### Conditional Usage\n *\n * You can also conditionally add instructions based on the state of your app.\n *\n * ```tsx\n * import { useCopilotAdditionalInstructions } from \"@copilotkit/react-core\";\n *\n * export function MyComponent() {\n *   const [showInstructions, setShowInstructions] = useState(false);\n *\n *   useCopilotAdditionalInstructions({\n *     available: showInstructions ? \"enabled\" : \"disabled\",\n *     instructions: \"Do not answer questions about the weather.\",\n *   });\n * }\n * ```\n */\nimport { useEffect } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\n\n/**\n * Options for the useCopilotAdditionalInstructions hook.\n */\nexport interface UseCopilotAdditionalInstructionsOptions {\n  /**\n   * The instructions to be added to the Copilot. Will be added to the instructions like so:\n   *\n   * ```txt\n   * You are a helpful assistant.\n   * Additionally, follow these instructions:\n   * - Do not answer questions about the weather.\n   * - Do not answer questions about the stock market.\n   * ```\n   */\n  instructions: string;\n\n  /**\n   * Whether the instructions are available to the Copilot.\n   */\n  available?: \"enabled\" | \"disabled\";\n}\n\n/**\n * Adds the given instructions to the Copilot context.\n */\nexport function useCopilotAdditionalInstructions(\n  { instructions, available = \"enabled\" }: UseCopilotAdditionalInstructionsOptions,\n  dependencies?: any[],\n) {\n  const { setAdditionalInstructions } = useCopilotContext();\n\n  useEffect(() => {\n    if (available === \"disabled\") return;\n\n    setAdditionalInstructions((prevInstructions) => [...(prevInstructions || []), instructions]);\n\n    return () => {\n      setAdditionalInstructions(\n        (prevInstructions) =>\n          prevInstructions?.filter((instruction) => instruction !== instructions) || [],\n      );\n    };\n  }, [available, instructions, setAdditionalInstructions, ...(dependencies || [])]);\n}\n"],"names":[],"mappings":";;;;;AAsCA,SAAS,iBAAiB;;;AA4BnB,SAAS,iCACd,EAAE,YAAA,EAAc,YAAY,SAAA,CAAU,CAAA,EACtC,YAAA,EACA;IACA,MAAM,EAAE,yBAAA,CAA0B,CAAA,GAAI,uMAAA,CAAkB;IAExD,CAAA,GAAA,6JAAA,CAAA,YAAA;sDAAU,MAAM;YACd,IAAI,cAAc,YAAY;YAE9B;8DAA0B,CAAC,mBAAqB,CAAC;2BAAI,oBAAoB,CAAC,CAAA;wBAAI,YAAY;qBAAC;;YAE3F;8DAAO,MAAM;oBACX;sEACE,CAAC,mBAAA,CACC,oBAAA,OAAA,KAAA,IAAA,iBAAkB,MAAA;8EAAO,CAAC,cAAgB,gBAAgB;4EAAA,KAAiB,CAAC,CAAA;;gBAElF;;QACF;qDAAG;QAAC;QAAW;QAAc,2BAA2B;WAAI,gBAAgB,CAAC,CAAE;KAAC;AAClF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3458, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-copilot-action.ts"],"sourcesContent":["/**\n * Example usage of useCopilotAction with complex parameters:\n *\n * @example\n * useCopilotAction({\n *   name: \"myAction\",\n *   parameters: [\n *     { name: \"arg1\", type: \"string\", enum: [\"option1\", \"option2\", \"option3\"], required: false },\n *     { name: \"arg2\", type: \"number\" },\n *     {\n *       name: \"arg3\",\n *       type: \"object\",\n *       attributes: [\n *         { name: \"nestedArg1\", type: \"boolean\" },\n *         { name: \"xyz\", required: false },\n *       ],\n *     },\n *     { name: \"arg4\", type: \"number[]\" },\n *   ],\n *   handler: ({ arg1, arg2, arg3, arg4 }) => {\n *     const x = arg3.nestedArg1;\n *     const z = arg3.xyz;\n *     console.log(arg1, arg2, arg3);\n *   },\n * });\n *\n * @example\n * // Simple action without parameters\n * useCopilotAction({\n *   name: \"myAction\",\n *   handler: () => {\n *     console.log(\"No parameters provided.\");\n *   },\n * });\n *\n * @example\n * // Interactive action with UI rendering and response handling\n * useCopilotAction({\n *   name: \"handleMeeting\",\n *   description: \"Handle a meeting by booking or canceling\",\n *   parameters: [\n *     {\n *       name: \"meeting\",\n *       type: \"string\",\n *       description: \"The meeting to handle\",\n *       required: true,\n *     },\n *     {\n *       name: \"date\",\n *       type: \"string\",\n *       description: \"The date of the meeting\",\n *       required: true,\n *     },\n *     {\n *       name: \"title\",\n *       type: \"string\",\n *       description: \"The title of the meeting\",\n *       required: true,\n *     },\n *   ],\n *   renderAndWaitForResponse: ({ args, respond, status }) => {\n *     const { meeting, date, title } = args;\n *     return (\n *       <MeetingConfirmationDialog\n *         meeting={meeting}\n *         date={date}\n *         title={title}\n *         onConfirm={() => respond('meeting confirmed')}\n *         onCancel={() => respond('meeting canceled')}\n *       />\n *     );\n *   },\n * });\n *\n * @example\n * // Catch all action allows you to render actions that are not defined in the frontend\n * useCopilotAction({\n *   name: \"*\",\n *   render: ({ name, args, status, result, handler, respond }) => {\n *     return <div>Rendering action: {name}</div>;\n *   },\n * });\n */\n\n/**\n * <img src=\"/images/use-copilot-action/useCopilotAction.gif\" width=\"500\" />\n * `useCopilotAction` is a React hook that you can use in your application to provide\n * custom actions that can be called by the AI. Essentially, it allows the Copilot to\n * execute these actions contextually during a chat, based on the user's interactions\n * and needs.\n *\n * Here's how it works:\n *\n * Use `useCopilotAction` to set up actions that the Copilot can call. To provide\n * more context to the Copilot, you can provide it with a `description` (for example to explain\n * what the action does, under which conditions it can be called, etc.).\n *\n * Then you define the parameters of the action, which can be simple, e.g. primitives like strings or numbers,\n * or complex, e.g. objects or arrays.\n *\n * Finally, you provide a `handler` function that receives the parameters and returns a result.\n * CopilotKit takes care of automatically inferring the parameter types, so you get type safety\n * and autocompletion for free.\n *\n * To render a custom UI for the action, you can provide a `render()` function. This function\n * lets you render a custom component or return a string to display.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * useCopilotAction({\n *   name: \"sayHello\",\n *   description: \"Say hello to someone.\",\n *   parameters: [\n *     {\n *       name: \"name\",\n *       type: \"string\",\n *       description: \"name of the person to say greet\",\n *     },\n *   ],\n *   handler: async ({ name }) => {\n *     alert(`Hello, ${name}!`);\n *   },\n * });\n * ```\n *\n * ## Generative UI\n *\n * This hooks enables you to dynamically generate UI elements and render them in the copilot chat. For more information, check out the [Generative UI](/guides/generative-ui) page.\n */\nimport { Parameter, randomId } from \"@copilotkit/shared\";\nimport { createElement, Fragment, useEffect, useRef } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { useAsyncCallback } from \"../components/error-boundary/error-utils\";\nimport {\n  ActionRenderProps,\n  ActionRenderPropsNoArgsWait,\n  ActionRenderPropsWait,\n  CatchAllFrontendAction,\n  FrontendAction,\n} from \"../types/frontend-action\";\nimport { useToast } from \"../components/toast/toast-provider\";\n\n// We implement useCopilotAction dependency handling so that\n// the developer has the option to not provide any dependencies.\n// In this case, we assume they want to update the handler on each rerender.\n// To avoid getting stuck in an infinite loop, we update the handler directly,\n// skipping React state updates.\n// This is ok in this case, because the handler is not part of any UI that\n// needs to be updated.\n// useCallback, useMemo or other memoization techniques are not suitable here,\n// because they will cause a infinite rerender loop.\nexport function useCopilotAction<const T extends Parameter[] | [] = []>(\n  action: FrontendAction<T> | CatchAllFrontendAction,\n  dependencies?: any[],\n): void {\n  const { setAction, removeAction, actions, chatComponentsCache } = useCopilotContext();\n  const idRef = useRef<string>(randomId());\n  const renderAndWaitRef = useRef<RenderAndWaitForResponse | null>(null);\n  const { addToast } = useToast();\n\n  // clone the action to avoid mutating the original object\n  action = { ...action };\n\n  // If the developer provides a renderAndWaitForResponse function, we transform the action\n  // to use a promise internally, so that we can treat it like a normal action.\n  if (\n    // renderAndWaitForResponse is not available for catch all actions\n    isFrontendAction(action) &&\n    // check if renderAndWaitForResponse is set\n    (action.renderAndWait || action.renderAndWaitForResponse)\n  ) {\n    const renderAndWait = action.renderAndWait || action.renderAndWaitForResponse;\n    // remove the renderAndWait function from the action\n    action.renderAndWait = undefined;\n    action.renderAndWaitForResponse = undefined;\n    // add a handler that will be called when the action is executed\n    action.handler = useAsyncCallback(async () => {\n      // we create a new promise when the handler is called\n      let resolve: (result: any) => void;\n      let reject: (error: any) => void;\n      const promise = new Promise<any>((resolvePromise, rejectPromise) => {\n        resolve = resolvePromise;\n        reject = rejectPromise;\n      });\n      renderAndWaitRef.current = { promise, resolve: resolve!, reject: reject! };\n      // then we await the promise (it will be resolved in the original renderAndWait function)\n      return await promise;\n    }, []) as any;\n\n    // add a render function that will be called when the action is rendered\n    action.render = ((props: ActionRenderProps<T>): React.ReactElement => {\n      // Specifically for renderAndWaitForResponse the executing state is set too early, causing a race condition\n      // To fit it: we will wait for the handler to be ready\n      let status = props.status;\n      if (props.status === \"executing\" && !renderAndWaitRef.current) {\n        status = \"inProgress\";\n      }\n      // Create type safe waitProps based on whether T extends empty array or not\n      const waitProps = {\n        status,\n        args: props.args,\n        result: props.result,\n        handler: status === \"executing\" ? renderAndWaitRef.current!.resolve : undefined,\n        respond: status === \"executing\" ? renderAndWaitRef.current!.resolve : undefined,\n      } as T extends [] ? ActionRenderPropsNoArgsWait<T> : ActionRenderPropsWait<T>;\n\n      // Type guard to check if renderAndWait is for no args case\n      const isNoArgsRenderWait = (\n        _fn:\n          | ((props: ActionRenderPropsNoArgsWait<T>) => React.ReactElement)\n          | ((props: ActionRenderPropsWait<T>) => React.ReactElement),\n      ): _fn is (props: ActionRenderPropsNoArgsWait<T>) => React.ReactElement => {\n        return action.parameters?.length === 0;\n      };\n\n      // Safely call renderAndWait with correct props type\n      if (renderAndWait) {\n        if (isNoArgsRenderWait(renderAndWait)) {\n          return renderAndWait(waitProps as ActionRenderPropsNoArgsWait<T>);\n        } else {\n          return renderAndWait(waitProps as ActionRenderPropsWait<T>);\n        }\n      }\n\n      // Return empty Fragment instead of null\n      return createElement(Fragment);\n    }) as any;\n  }\n\n  // If the developer doesn't provide dependencies, we assume they want to\n  // update handler and render function when the action object changes.\n  // This ensures that any captured variables in the handler are up to date.\n  if (dependencies === undefined) {\n    if (actions[idRef.current]) {\n      // catch all actions don't have a handler\n      if (isFrontendAction(action)) {\n        actions[idRef.current].handler = action.handler as any;\n      }\n      if (typeof action.render === \"function\") {\n        if (chatComponentsCache.current !== null) {\n          // TODO: using as any here because the type definitions are getting to tricky\n          // not wasting time on this now - we know the types are compatible\n          chatComponentsCache.current.actions[action.name] = action.render as any;\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    const hasDuplicate = Object.values(actions).some(\n      (otherAction) => otherAction.name === action.name && otherAction !== actions[idRef.current],\n    );\n\n    if (hasDuplicate) {\n      addToast({\n        type: \"warning\",\n        message: `Found an already registered action with name ${action.name}.`,\n        id: `dup-action-${action.name}`,\n      });\n    }\n  }, [actions]);\n\n  useEffect(() => {\n    setAction(idRef.current, action as any);\n    if (chatComponentsCache.current !== null && action.render !== undefined) {\n      // see comment about type safety above\n      chatComponentsCache.current.actions[action.name] = action.render as any;\n    }\n    return () => {\n      // NOTE: For now, we don't remove the chatComponentsCache entry when the action is removed.\n      // This is because we currently don't have access to the messages array in CopilotContext.\n      // UPDATE: We now have access, we should remove the entry if not referenced by any message.\n      removeAction(idRef.current);\n    };\n  }, [\n    setAction,\n    removeAction,\n    isFrontendAction(action) ? action.description : undefined,\n    action.name,\n    isFrontendAction(action) ? action.disabled : undefined,\n    isFrontendAction(action) ? action.available : undefined,\n    // This should be faster than deep equality checking\n    // In addition, all major JS engines guarantee the order of object keys\n    JSON.stringify(isFrontendAction(action) ? action.parameters : []),\n    // include render only if it's a string\n    typeof action.render === \"string\" ? action.render : undefined,\n    // dependencies set by the developer\n    ...(dependencies || []),\n  ]);\n}\n\nfunction isFrontendAction<T extends Parameter[]>(\n  action: FrontendAction<T> | CatchAllFrontendAction,\n): action is FrontendAction<T> {\n  return action.name !== \"*\";\n}\n\ninterface RenderAndWaitForResponse {\n  promise: Promise<any>;\n  resolve: (result: any) => void;\n  reject: (error: any) => void;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3591, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3597, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-copilot-authenticated-action.ts"],"sourcesContent":["import { Parameter } from \"@copilotkit/shared\";\nimport { Fragment, useCallback, useRef } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { FrontendAction, ActionRenderProps } from \"../types/frontend-action\";\nimport { useCopilotAction } from \"./use-copilot-action\";\nimport React from \"react\";\n\n/**\n * Hook to create an authenticated action that requires user sign-in before execution.\n *\n * @remarks\n * This feature is only available when using CopilotKit's hosted cloud service.\n * To use this feature, sign up at https://cloud.copilotkit.ai to get your publicApiKey.\n *\n * @param action - The frontend action to be wrapped with authentication\n * @param dependencies - Optional array of dependencies that will trigger recreation of the action when changed\n */\nexport function useCopilotAuthenticatedAction_c<T extends Parameter[]>(\n  action: FrontendAction<T>,\n  dependencies?: any[],\n): void {\n  const { authConfig_c, authStates_c, setAuthStates_c } = useCopilotContext();\n  const pendingActionRef = useRef<ActionRenderProps<Parameter[]> | null>(null);\n\n  const executeAction = useCallback(\n    (props: ActionRenderProps<Parameter[]>) => {\n      if (typeof action.render === \"function\") {\n        return action.render(props);\n      }\n      return action.render || React.createElement(Fragment);\n    },\n    [action],\n  );\n\n  const wrappedRender = useCallback(\n    (props: ActionRenderProps<Parameter[]>): string | React.ReactElement => {\n      const isAuthenticated = Object.values(authStates_c || {}).some(\n        (state) => state.status === \"authenticated\",\n      );\n\n      if (!isAuthenticated) {\n        // Store action details for later execution\n        pendingActionRef.current = props;\n\n        return authConfig_c?.SignInComponent\n          ? React.createElement(authConfig_c.SignInComponent, {\n              onSignInComplete: (authState) => {\n                setAuthStates_c?.((prev) => ({ ...prev, [action.name]: authState }));\n                if (pendingActionRef.current) {\n                  executeAction(pendingActionRef.current);\n                  pendingActionRef.current = null;\n                }\n              },\n            })\n          : React.createElement(Fragment);\n      }\n\n      return executeAction(props);\n    },\n    [action, authStates_c, setAuthStates_c],\n  );\n\n  useCopilotAction(\n    {\n      ...action,\n      render: wrappedRender,\n    } as FrontendAction<T>,\n    dependencies,\n  );\n}\n"],"names":[],"mappings":";;;;;;;AACA,SAAS,UAAU,aAAa,cAAc;;;;;;AAgBvC,SAAS,gCACd,MAAA,EACA,YAAA,EACM;IACN,MAAM,EAAE,YAAA,EAAc,YAAA,EAAc,eAAA,CAAgB,CAAA,qLAAI,qBAAA,CAAkB;IAC1E,MAAM,qLAAmB,SAAA,EAA8C,IAAI;IAE3E,MAAM,gBAAgB,gLAAA;sEACpB,CAAC,UAA0C;YACzC,IAAI,OAAO,OAAO,MAAA,KAAW,YAAY;gBACvC,OAAO,OAAO,MAAA,CAAO,KAAK;YAC5B;YACA,OAAO,OAAO,MAAA,kKAAU,UAAA,CAAM,aAAA,CAAc,yKAAQ;QACtD;qEACA;QAAC,MAAM;KAAA;IAGT,MAAM,kLAAgB,cAAA;sEACpB,CAAC,UAAuE;YACtE,MAAM,kBAAkB,OAAO,MAAA,CAAO,gBAAgB,CAAC,CAAC,EAAE,IAAA;8FACxD,CAAC,QAAU,MAAM,MAAA,KAAW;;YAG9B,IAAI,CAAC,iBAAiB;gBAEpB,iBAAiB,OAAA,GAAU;gBAE3B,OAAA,CAAO,gBAAA,OAAA,KAAA,IAAA,aAAc,eAAA,kKACjB,UAAA,CAAM,aAAA,CAAc,aAAa,eAAA,EAAiB;oBAChD,gBAAA;sFAAkB,CAAC,cAAc;4BAC/B,mBAAA,OAAA,KAAA,IAAA;8FAAkB,CAAC,0LAAU,gBAAA,EAAA,CAAA,GAAA,8KAAA,CAAA,iBAAA,EAAA,CAAA,GAAK,OAAL;wCAAW,CAAC,OAAO,IAAI,CAAA,EAAG;oCAAU;;4BACjE,IAAI,iBAAiB,OAAA,EAAS;gCAC5B,cAAc,iBAAiB,OAAO;gCACtC,iBAAiB,OAAA,GAAU;4BAC7B;wBACF;;gBACF,CAAC,IACD,wKAAA,CAAM,aAAA,+JAAc,WAAQ;YAClC;YAEA,OAAO,cAAc,KAAK;QAC5B;qEACA;QAAC;QAAQ;QAAc,eAAe;KAAA;IAGxC,CAAA,GAAA,8KAAA,CAAA,mBAAA,qLACE,gBAAA,EAAA,CAAA,GAAA,8KAAA,CAAA,iBAAA,EAAA,CAAA,GACK,SADL;QAEE,QAAQ;IACV,IACA;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3665, "column": 0}, "map": {"version":3,"sources":["file:///Users/atefataya/Documents/Data%20Science/CopilotKit/CopilotKit-sample/restaurant-finder-ui/node_modules/%40copilotkit/react-core/src/hooks/use-copilot-readable.ts"],"sourcesContent":["/**\n * `useCopilotReadable` is a React hook that provides app-state and other information\n * to the Copilot. Optionally, the hook can also handle hierarchical state within your\n * application, passing these parent-child relationships to the Copilot.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * In its most basic usage, useCopilotReadable accepts a single string argument\n * representing any piece of app state, making it available for the Copilot to use\n * as context when responding to user input.\n *\n * ```tsx\n * import { useCopilotReadable } from \"@copilotkit/react-core\";\n *\n * export function MyComponent() {\n *   const [employees, setEmployees] = useState([]);\n *\n *   useCopilotReadable({\n *     description: \"The list of employees\",\n *     value: employees,\n *   });\n * }\n * ```\n *\n * ### Nested Components\n *\n * Optionally, you can maintain the hierarchical structure of information by passing\n * `parentId`. This allows you to use `useCopilotReadable` in nested components:\n *\n * ```tsx /employeeContextId/1 {17,23}\n * import { useCopilotReadable } from \"@copilotkit/react-core\";\n *\n * function Employee(props: EmployeeProps) {\n *   const { employeeName, workProfile, metadata } = props;\n *\n *   // propagate any information to copilot\n *   const employeeContextId = useCopilotReadable({\n *     description: \"Employee name\",\n *     value: employeeName\n *   });\n *\n *   // Pass a parentID to maintain a hierarchical structure.\n *   // Especially useful with child React components, list elements, etc.\n *   useCopilotReadable({\n *     description: \"Work profile\",\n *     value: workProfile.description(),\n *     parentId: employeeContextId\n *   });\n *\n *   useCopilotReadable({\n *     description: \"Employee metadata\",\n *     value: metadata.description(),\n *     parentId: employeeContextId\n *   });\n *\n *   return (\n *     // Render as usual...\n *   );\n * }\n * ```\n */\nimport { useEffect, useRef } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\n\n/**\n * Options for the useCopilotReadable hook.\n */\nexport interface UseCopilotReadableOptions {\n  /**\n   * The description of the information to be added to the Copilot context.\n   */\n  description: string;\n  /**\n   * The value to be added to the Copilot context. Object values are automatically stringified.\n   */\n  value: any;\n  /**\n   * The ID of the parent context, if any.\n   */\n  parentId?: string;\n  /**\n   * An array of categories to control which context are visible where. Particularly useful\n   * with CopilotTextarea (see `useMakeAutosuggestionFunction`)\n   */\n  categories?: string[];\n\n  /**\n   * Whether the context is available to the Copilot.\n   */\n  available?: \"enabled\" | \"disabled\";\n\n  /**\n   * A custom conversion function to use to serialize the value to a string. If not provided, the value\n   * will be serialized using `JSON.stringify`.\n   */\n  convert?: (description: string, value: any) => string;\n}\n\nfunction convertToJSON(description: string, value: any): string {\n  return `${description}: ${typeof value === \"string\" ? value : JSON.stringify(value)}`;\n}\n\n/**\n * Adds the given information to the Copilot context to make it readable by Copilot.\n */\nexport function useCopilotReadable(\n  {\n    description,\n    value,\n    parentId,\n    categories,\n    convert,\n    available = \"enabled\",\n  }: UseCopilotReadableOptions,\n  dependencies?: any[],\n): string | undefined {\n  const { addContext, removeContext } = useCopilotContext();\n  const idRef = useRef<string>();\n  convert = convert || convertToJSON;\n\n  const information = convert(description, value);\n\n  useEffect(() => {\n    if (available === \"disabled\") return;\n\n    const id = addContext(information, parentId, categories);\n    idRef.current = id;\n\n    return () => {\n      removeContext(id);\n    };\n  }, [available, information, parentId, addContext, removeContext, ...(dependencies || [])]);\n\n  return idRef.current;\n}\n"],"names":[],"mappings":";;;;;AA+DA,SAAS,WAAW,cAAc;;;AAqClC,SAAS,cAAc,WAAA,EAAqB,KAAA,EAAoB;IAC9D,OAAO,GAAG,YAAA,EAAA,EAAgB,OAAO,UAAU,WAAW,QAAQ,KAAK,SAAA,CAAU,KAAK,GAAA;AACpF;AAKO,SAAS,mBACd,EACE,WAAA,EACA,KAAA,EACA,QAAA,EACA,UAAA,EACA,OAAA,EACA,YAAY,SAAA,EACd,EACA,YAAA,EACoB;IACpB,MAAM,EAAE,UAAA,EAAY,aAAA,CAAc,CAAA,sLAAI,oBAAA,CAAkB;IACxD,MAAM,SAAQ,0KAAA,CAAe;IAC7B,UAAU,WAAW;IAErB,MAAM,cAAc,QAAQ,aAAa,KAAK;IAE9C,CAAA,GAAA,6JAAA,CAAA,YAAA;wCAAU,MAAM;YACd,IAAI,cAAc,YAAY;YAE9B,MAAM,KAAK,WAAW,aAAa,UAAU,UAAU;YACvD,MAAM,OAAA,GAAU;YAEhB;gDAAO,MAAM;oBACX,cAAc,EAAE;gBAClB;;QACF;uCAAG;QAAC;QAAW;QAAa;QAAU;QAAY,eAAe;WAAI,gBAAgB,CAAC,CAAE;KAAC;IAEzF,OAAO,MAAM,OAAA;AACf","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3704, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}